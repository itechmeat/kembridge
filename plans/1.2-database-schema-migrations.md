# KEMBridge Database Schema & Migrations

## üìã Overview

–î–µ—Ç–∞–ª—å–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Å–æ–∑–¥–∞–Ω–∏—é —Å—Ö–µ–º—ã –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ –º–∏–≥—Ä–∞—Ü–∏–π –¥–ª—è KEMBridge. –í–∫–ª—é—á–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –∫ –¥–∞–Ω–Ω—ã–º, –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã –∏ –ø–æ—à–∞–≥–æ–≤—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–±–ª–∏—Ü —Å —É—á–µ—Ç–æ–º —Å–ø–µ—Ü–∏—Ñ–∏–∫–∏ –∫—Ä–æ—Å—Å-—á–µ–π–Ω –º–æ—Å—Ç–∞ –∏ –ø–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏.

## üîç Database Requirements Analysis

### –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è KEMBridge

#### –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∞—É–¥–∏—Ç
**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã:**
- ‚úÖ **–ü–æ–ª–Ω—ã–π –∞—É–¥–∏—Ç**: –í—Å–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å—Å—è
- ‚úÖ **–ü–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤—ã–µ –∫–ª—é—á–∏**: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ ML-KEM-1024 –∫–ª—é—á–µ–π
- ‚úÖ **–¶–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö**: –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–¥–∞–ª–µ–Ω–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–ø–∏—Å–µ–π
- ‚úÖ **–í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏**: UTC timestamps –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
- ‚úÖ **–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ**: –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —à–∏—Ñ—Ä—É—é—Ç—Å—è –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

#### Web3 Authentication
**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:**
- üîê **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∏**: –û–¥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ—à–µ–ª—å–∫–æ–≤
- üîê **–ú—É–ª—å—Ç–∏—á–µ–π–Ω –ø–æ–¥–¥–µ—Ä–∂–∫–∞**: Ethereum (secp256k1) –∏ NEAR (ed25519) –ø–æ–¥–ø–∏—Å–∏
- üîê **Session management**: JWT —Ç–æ–∫–µ–Ω—ã —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Ä–æ—Ç–∞—Ü–∏–∏
- üîê **Nonce tracking**: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ replay attacks

#### Cross-chain Transactions
**–°–ª–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–æ—Å—Å-—á–µ–π–Ω –æ–ø–µ—Ä–∞—Ü–∏–π:**
- ‚õìÔ∏è **–ê—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç—å**: –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ª–∏–±–æ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –ø–æ–ª–Ω–æ—Å—Ç—å—é, –ª–∏–±–æ –æ—Ç–∫–∞—Ç—ã–≤–∞—é—Ç—Å—è
- ‚õìÔ∏è **–°–æ—Å—Ç–æ—è–Ω–∏—è**: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (pending, locked, confirmed, failed)
- ‚õìÔ∏è **–í—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è**: Timeouts –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å—à–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
- ‚õìÔ∏è **Rollback –º–µ—Ö–∞–Ω–∏–∑–º**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫–∞—Ç–∞ –ø—Ä–∏ —Å–±–æ—è—Ö

#### AI Risk Analysis
**–ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –∏ –∞–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫–æ–≤:**
- üß† **–ü—Ä–æ—Ñ–∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π**: –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≤–µ–¥–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- üß† **Risk scoring**: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ä–∏—Å–∫-—Å–∫–æ—Ä—ã –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- üß† **–ü–∞—Ç—Ç–µ—Ä–Ω—ã –ø–æ–≤–µ–¥–µ–Ω–∏—è**: –ê–Ω–∞–ª–∏–∑ —á–∞—Å—Ç–æ—Ç—ã, —Ä–∞–∑–º–µ—Ä–æ–≤ –∏ –≤—Ä–µ–º–µ–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–π
- üß† **Blacklists**: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Å–ø–∏—Å–∫–∏ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤

### PostgreSQL 18 Beta 1 Advantages

#### –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è KEMBridge
**–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- ‚úÖ **OAuth 2.0 –ø–æ–¥–¥–µ—Ä–∂–∫–∞**: –í—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ OAuth –¥–ª—è –±—É–¥—É—â–∏—Ö –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π
- ‚úÖ **–£–ª—É—á—à–µ–Ω–Ω—ã–π JSONB**: –õ—É—á—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –∫–ª—é—á–µ–π
- ‚úÖ **Enhanced Audit**: –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∞—É–¥–∏—Ç–∞ –¥–ª—è compliance
- ‚úÖ **Performance improvements**: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è time-series –¥–∞–Ω–Ω—ã—Ö
- ‚úÖ **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å**: –£–ª—É—á—à–µ–Ω–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è sensitive data

#### SQL Extensions –¥–ª—è KEMBridge
```sql
-- –í–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";    -- UUID generation
CREATE EXTENSION IF NOT EXISTS "pg_crypto";    -- Encryption functions
CREATE EXTENSION IF NOT EXISTS "btree_gin";    -- GIN indexes for better performance
CREATE EXTENSION IF NOT EXISTS "pg_trgm";      -- Text search optimization
```

## üèóÔ∏è Database Schema Design

### Schema Overview
```mermaid
erDiagram
    USERS ||--o{ USER_AUTH_METHODS : has
    USERS ||--o{ USER_SESSIONS : creates
    USERS ||--o{ TRANSACTIONS : initiates
    USERS ||--o{ QUANTUM_KEYS : owns
    USERS ||--o{ AUDIT_LOGS : generates
    
    USER_AUTH_METHODS ||--o{ USER_SESSIONS : used_for
    TRANSACTIONS ||--o{ AUDIT_LOGS : logs
    QUANTUM_KEYS ||--o{ TRANSACTIONS : secures
    
    USERS {
        uuid id PK
        string username
        jsonb profile_data
        timestamp created_at
        timestamp updated_at
        boolean is_active
        jsonb risk_profile
    }
    
    USER_AUTH_METHODS {
        uuid id PK
        uuid user_id FK
        string chain_type
        string wallet_address
        string public_key
        jsonb signature_params
        timestamp first_used_at
        timestamp last_used_at
        boolean is_verified
    }
    
    USER_SESSIONS {
        uuid id PK
        uuid user_id FK
        uuid auth_method_id FK
        string jwt_token_hash
        jsonb session_data
        timestamp created_at
        timestamp expires_at
        timestamp last_activity_at
        boolean is_active
    }
    
    TRANSACTIONS {
        uuid id PK
        uuid user_id FK
        string source_chain
        string destination_chain
        string source_token
        string destination_token
        decimal amount_in
        decimal amount_out
        string source_tx_hash
        string destination_tx_hash
        string status
        jsonb encrypted_data
        uuid quantum_key_id FK
        decimal risk_score
        jsonb risk_factors
        timestamp created_at
        timestamp updated_at
        timestamp completed_at
        timestamp expires_at
    }
    
    QUANTUM_KEYS {
        uuid id PK
        uuid user_id FK
        string key_type
        bytea public_key
        bytea encrypted_private_key
        string encryption_algorithm
        jsonb key_metadata
        timestamp created_at
        timestamp expires_at
        boolean is_active
    }
    
    AUDIT_LOGS {
        uuid id PK
        uuid user_id FK
        uuid transaction_id FK
        string event_type
        string event_category
        jsonb event_data
        string ip_address
        string user_agent
        timestamp created_at
        string severity
    }
```

### Core Tables Design

#### 1. Users Table - –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
```sql
-- –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–æ–≤
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(255) UNIQUE,  -- Optional readable name
    profile_data JSONB DEFAULT '{}',  -- Flexible user metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_active BOOLEAN DEFAULT true,
    risk_profile JSONB DEFAULT '{}',  -- AI-generated risk profile
    
    -- Constraints
    CONSTRAINT users_username_length CHECK (char_length(username) >= 3),
    CONSTRAINT users_profile_is_object CHECK (jsonb_typeof(profile_data) = 'object'),
    CONSTRAINT users_risk_profile_is_object CHECK (jsonb_typeof(risk_profile) = 'object')
);

-- Performance indexes
CREATE INDEX idx_users_username ON users(username) WHERE username IS NOT NULL;
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_users_is_active ON users(is_active) WHERE is_active = true;
CREATE INDEX idx_users_risk_profile_gin ON users USING GIN (risk_profile);

-- Audit trigger setup
CREATE TRIGGER users_update_timestamp 
    BEFORE UPDATE ON users 
    FOR EACH ROW 
    EXECUTE FUNCTION update_timestamp();
```

#### 2. User Auth Methods - Web3 –∫–æ—à–µ–ª—å–∫–∏
```sql
-- –•—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (Ethereum, NEAR, etc)
CREATE TABLE user_auth_methods (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    chain_type VARCHAR(50) NOT NULL,  -- 'ethereum', 'near', etc
    wallet_address VARCHAR(255) NOT NULL,  -- Blockchain address
    public_key TEXT,  -- For signature verification
    signature_params JSONB DEFAULT '{}',  -- Chain-specific parameters
    first_used_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_used_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_verified BOOLEAN DEFAULT false,
    
    -- Constraints
    CONSTRAINT auth_methods_chain_type_valid 
        CHECK (chain_type IN ('ethereum', 'near')),
    CONSTRAINT auth_methods_wallet_address_format 
        CHECK (
            (chain_type = 'ethereum' AND wallet_address ~ '^0x[a-fA-F0-9]{40}$') OR
            (chain_type = 'near' AND char_length(wallet_address) > 2)
        ),
    CONSTRAINT auth_methods_unique_wallet 
        UNIQUE (chain_type, wallet_address)
);

-- Performance indexes
CREATE INDEX idx_auth_methods_user_id ON user_auth_methods(user_id);
CREATE INDEX idx_auth_methods_wallet_lookup ON user_auth_methods(chain_type, wallet_address);
CREATE INDEX idx_auth_methods_verified ON user_auth_methods(is_verified) WHERE is_verified = true;
CREATE INDEX idx_auth_methods_last_used ON user_auth_methods(last_used_at);

-- Audit trigger
CREATE TRIGGER auth_methods_update_last_used 
    BEFORE UPDATE ON user_auth_methods 
    FOR EACH ROW 
    EXECUTE FUNCTION update_last_used_timestamp();
```

#### 3. User Sessions - JWT —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
```sql
-- –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–µ—Å—Å–∏–∏ —Å JWT —Ç–æ–∫–µ–Ω–∞–º–∏
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    auth_method_id UUID NOT NULL REFERENCES user_auth_methods(id) ON DELETE CASCADE,
    jwt_token_hash VARCHAR(255) NOT NULL UNIQUE,  -- SHA-256 hash of JWT
    session_data JSONB DEFAULT '{}',  -- Additional session metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    last_activity_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_active BOOLEAN DEFAULT true,
    
    -- Constraints
    CONSTRAINT sessions_expires_after_created 
        CHECK (expires_at > created_at),
    CONSTRAINT sessions_token_hash_format 
        CHECK (char_length(jwt_token_hash) = 64),  -- SHA-256 hash length
    CONSTRAINT sessions_data_is_object 
        CHECK (jsonb_typeof(session_data) = 'object')
);

-- Performance indexes
CREATE INDEX idx_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_sessions_token_hash ON user_sessions(jwt_token_hash);
CREATE INDEX idx_sessions_active ON user_sessions(is_active, expires_at) WHERE is_active = true;
CREATE INDEX idx_sessions_cleanup ON user_sessions(expires_at) WHERE is_active = false;

-- Automatic cleanup of expired sessions
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS void AS $$
BEGIN
    UPDATE user_sessions 
    SET is_active = false 
    WHERE expires_at < NOW() AND is_active = true;
END;
$$ LANGUAGE plpgsql;
```

#### 4. Transactions - –ö—Ä–æ—Å—Å-—á–µ–π–Ω –æ–ø–µ—Ä–∞—Ü–∏–∏
```sql
-- –û—Å–Ω–æ–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥–ª—è –≤—Å–µ—Ö –∫—Ä–æ—Å—Å-—á–µ–π–Ω —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    
    -- Cross-chain details
    source_chain VARCHAR(50) NOT NULL,
    destination_chain VARCHAR(50) NOT NULL,
    source_token VARCHAR(100) NOT NULL,
    destination_token VARCHAR(100) NOT NULL,
    amount_in DECIMAL(36, 18) NOT NULL,  -- Support for very large/small amounts
    amount_out DECIMAL(36, 18),
    
    -- Blockchain transaction hashes
    source_tx_hash VARCHAR(255),
    destination_tx_hash VARCHAR(255),
    
    -- Transaction state management
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    
    -- Quantum cryptography integration
    encrypted_data BYTEA,  -- Encrypted transaction details
    quantum_key_id UUID REFERENCES quantum_keys(id),
    
    -- AI Risk analysis
    risk_score DECIMAL(5, 4) DEFAULT 0.0000,  -- 0.0000 to 1.0000
    risk_factors JSONB DEFAULT '{}',
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT transactions_valid_chains 
        CHECK (source_chain IN ('ethereum', 'near') AND destination_chain IN ('ethereum', 'near')),
    CONSTRAINT transactions_different_chains 
        CHECK (source_chain != destination_chain),
    CONSTRAINT transactions_positive_amounts 
        CHECK (amount_in > 0 AND (amount_out IS NULL OR amount_out > 0)),
    CONSTRAINT transactions_valid_status 
        CHECK (status IN ('pending', 'locked', 'confirmed', 'failed', 'cancelled', 'expired')),
    CONSTRAINT transactions_risk_score_range 
        CHECK (risk_score >= 0.0000 AND risk_score <= 1.0000),
    CONSTRAINT transactions_completion_logic 
        CHECK (
            (status IN ('confirmed', 'failed', 'cancelled') AND completed_at IS NOT NULL) OR
            (status NOT IN ('confirmed', 'failed', 'cancelled') AND completed_at IS NULL)
        )
);

-- Performance indexes for high-frequency queries
CREATE INDEX idx_transactions_user_id ON transactions(user_id);
CREATE INDEX idx_transactions_status ON transactions(status);
CREATE INDEX idx_transactions_created_at ON transactions(created_at);
CREATE INDEX idx_transactions_source_tx_hash ON transactions(source_tx_hash) WHERE source_tx_hash IS NOT NULL;
CREATE INDEX idx_transactions_destination_tx_hash ON transactions(destination_tx_hash) WHERE destination_tx_hash IS NOT NULL;
CREATE INDEX idx_transactions_risk_score ON transactions(risk_score) WHERE risk_score > 0.5;
CREATE INDEX idx_transactions_pending_expired ON transactions(status, expires_at) 
    WHERE status = 'pending' AND expires_at IS NOT NULL;

-- GIN index for risk factors analysis
CREATE INDEX idx_transactions_risk_factors_gin ON transactions USING GIN (risk_factors);

-- Composite indexes for complex queries
CREATE INDEX idx_transactions_user_status_created ON transactions(user_id, status, created_at);
CREATE INDEX idx_transactions_chains_status ON transactions(source_chain, destination_chain, status);
```

#### 5. Quantum Keys - –ü–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤—ã–µ –∫–ª—é—á–∏
```sql
-- –•—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –∫–ª—é—á–µ–π (ML-KEM-1024 –∏ –¥—Ä—É–≥–∏—Ö)
CREATE TABLE quantum_keys (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Key type and algorithm information
    key_type VARCHAR(50) NOT NULL DEFAULT 'ml-kem-1024',
    public_key BYTEA NOT NULL,  -- Raw public key bytes
    encrypted_private_key BYTEA NOT NULL,  -- AES-GCM encrypted private key
    encryption_algorithm VARCHAR(100) NOT NULL DEFAULT 'aes-256-gcm',
    
    -- Key metadata and lifecycle
    key_metadata JSONB DEFAULT '{}',  -- Algorithm parameters, etc.
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE,  -- Key rotation support
    is_active BOOLEAN DEFAULT true,
    
    -- Constraints
    CONSTRAINT quantum_keys_valid_type 
        CHECK (key_type IN ('ml-kem-1024', 'dilithium-5', 'sphincs+')),
    CONSTRAINT quantum_keys_valid_encryption 
        CHECK (encryption_algorithm IN ('aes-256-gcm', 'chacha20-poly1305')),
    CONSTRAINT quantum_keys_key_sizes 
        CHECK (
            (key_type = 'ml-kem-1024' AND octet_length(public_key) = 1568) OR
            (key_type != 'ml-kem-1024')  -- Other algorithms have different sizes
        ),
    CONSTRAINT quantum_keys_metadata_is_object 
        CHECK (jsonb_typeof(key_metadata) = 'object'),
    CONSTRAINT quantum_keys_expiry_logic 
        CHECK (expires_at IS NULL OR expires_at > created_at)
);

-- Security and performance indexes
CREATE INDEX idx_quantum_keys_user_id ON quantum_keys(user_id);
CREATE INDEX idx_quantum_keys_active ON quantum_keys(is_active, expires_at) WHERE is_active = true;
CREATE INDEX idx_quantum_keys_type ON quantum_keys(key_type);
CREATE INDEX idx_quantum_keys_expiry ON quantum_keys(expires_at) WHERE expires_at IS NOT NULL;

-- Metadata search index
CREATE INDEX idx_quantum_keys_metadata_gin ON quantum_keys USING GIN (key_metadata);
```

#### 6. Audit Logs - –ü–æ–ª–Ω—ã–π –∞—É–¥–∏—Ç —Å–∏—Å—Ç–µ–º—ã
```sql
-- Comprehensive audit logging for all system events
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),  -- Nullable for system events
    transaction_id UUID REFERENCES transactions(id),  -- Link to transaction if applicable
    
    -- Event classification
    event_type VARCHAR(100) NOT NULL,  -- 'login', 'transaction', 'key_generation', etc.
    event_category VARCHAR(50) NOT NULL,  -- 'auth', 'finance', 'security', 'system'
    event_data JSONB NOT NULL DEFAULT '{}',  -- Detailed event information
    
    -- Security context
    ip_address INET,  -- User IP address
    user_agent TEXT,  -- Browser/client information
    
    -- Timestamp and severity
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    severity VARCHAR(20) DEFAULT 'info',  -- 'info', 'warning', 'error', 'critical'
    
    -- Constraints
    CONSTRAINT audit_logs_valid_category 
        CHECK (event_category IN ('auth', 'finance', 'security', 'system', 'admin')),
    CONSTRAINT audit_logs_valid_severity 
        CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),
    CONSTRAINT audit_logs_event_data_is_object 
        CHECK (jsonb_typeof(event_data) = 'object')
);

-- High-performance indexes for audit queries
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_audit_logs_transaction_id ON audit_logs(transaction_id) WHERE transaction_id IS NOT NULL;
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_category_severity ON audit_logs(event_category, severity);
CREATE INDEX idx_audit_logs_ip_address ON audit_logs(ip_address) WHERE ip_address IS NOT NULL;

-- GIN index for complex event data queries
CREATE INDEX idx_audit_logs_event_data_gin ON audit_logs USING GIN (event_data);

-- Partitioning setup for large-scale audit data (by month)
CREATE TABLE audit_logs_y2024m01 PARTITION OF audit_logs
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
-- Additional partitions would be created automatically
```

### Database Functions and Triggers

#### Utility Functions
```sql
-- Update timestamp function for automatic updated_at fields
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Update last_used_at for auth methods
CREATE OR REPLACE FUNCTION update_last_used_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.last_used_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Audit log insertion function
CREATE OR REPLACE FUNCTION create_audit_log(
    p_user_id UUID,
    p_transaction_id UUID,
    p_event_type VARCHAR(100),
    p_event_category VARCHAR(50),
    p_event_data JSONB,
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL,
    p_severity VARCHAR(20) DEFAULT 'info'
)
RETURNS UUID AS $$
DECLARE
    audit_id UUID;
BEGIN
    INSERT INTO audit_logs (
        user_id, transaction_id, event_type, event_category, 
        event_data, ip_address, user_agent, severity
    ) VALUES (
        p_user_id, p_transaction_id, p_event_type, p_event_category,
        p_event_data, p_ip_address, p_user_agent, p_severity
    ) RETURNING id INTO audit_id;
    
    RETURN audit_id;
END;
$$ LANGUAGE plpgsql;
```

## üìä Migration Strategy

### Migration Files Structure
```
backend/migrations/
‚îú‚îÄ‚îÄ 001_initial_extensions.sql      # PostgreSQL extensions
‚îú‚îÄ‚îÄ 002_create_users_table.sql      # Users table
‚îú‚îÄ‚îÄ 003_create_auth_methods.sql     # Authentication methods
‚îú‚îÄ‚îÄ 004_create_user_sessions.sql    # Session management
‚îú‚îÄ‚îÄ 005_create_quantum_keys.sql     # Quantum cryptography keys
‚îú‚îÄ‚îÄ 006_create_transactions.sql     # Cross-chain transactions
‚îú‚îÄ‚îÄ 007_create_audit_logs.sql       # Audit logging
‚îú‚îÄ‚îÄ 008_create_functions.sql        # Database functions
‚îú‚îÄ‚îÄ 009_create_triggers.sql         # Triggers setup
‚îú‚îÄ‚îÄ 010_create_indexes.sql          # Additional indexes
‚îú‚îÄ‚îÄ 011_seed_data.sql               # Development seed data
‚îî‚îÄ‚îÄ 012_performance_optimizations.sql # Query optimizations
```

### SQLx Integration

#### Migration Configuration
```rust
// backend/crates/kembridge-database/src/migrations.rs
use sqlx::{PgPool, migrate::Migrator};

pub async fn run_migrations(pool: &PgPool) -> anyhow::Result<()> {
    // Create migrator from embedded migrations
    let migrator = Migrator::new(std::path::Path::new("./migrations")).await?;
    
    // Run all pending migrations
    migrator.run(pool).await?;
    
    tracing::info!("Database migrations completed successfully");
    Ok(())
}

pub async fn check_migration_status(pool: &PgPool) -> anyhow::Result<()> {
    let migrator = Migrator::new(std::path::Path::new("./migrations")).await?;
    
    // Check if database is up to date
    let pending = migrator.check_applied(pool).await?;
    
    if !pending.is_empty() {
        tracing::warn!("Found {} pending migrations", pending.len());
        for migration in pending {
            tracing::warn!("Pending migration: {}", migration.description);
        }
    } else {
        tracing::info!("Database is up to date");
    }
    
    Ok(())
}
```

## üîí Security Considerations

### Data Encryption Strategy
- **Private keys**: –®–∏—Ñ—Ä—É—é—Ç—Å—è AES-256-GCM –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
- **Transaction data**: –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **JWT tokens**: –•—Ä–∞–Ω—è—Ç—Å—è —Ç–æ–ª—å–∫–æ SHA-256 —Ö–µ—à–∏ —Ç–æ–∫–µ–Ω–æ–≤
- **Audit logs**: IP –∞–¥—Ä–µ—Å–∞ –∏ user agents –ª–æ–≥–∏—Ä—É—é—Ç—Å—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### Access Control
- **Row-level security**: –ë—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –¥–ª—è multi-tenant scenarios
- **Connection pooling**: –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
- **Query timeouts**: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –¥–æ–ª–≥–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
- **Backup encryption**: –†–µ–∑–µ—Ä–≤–Ω—ã–µ –∫–æ–ø–∏–∏ —à–∏—Ñ—Ä—É—é—Ç—Å—è

## üìà Performance Optimizations

### Indexing Strategy
- **Primary queries**: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —á–∞—Å—Ç—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
- **Composite indexes**: –î–ª—è —Å–ª–æ–∂–Ω—ã—Ö WHERE —É—Å–ª–æ–≤–∏–π
- **Partial indexes**: –¢–æ–ª—å–∫–æ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π
- **GIN indexes**: –î–ª—è JSONB –ø–æ–∏—Å–∫–∞

### Partitioning Plan
- **Audit logs**: –ü–∞—Ä—Ç–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –º–µ—Å—è—Ü–∞–º
- **Transactions**: –í–æ–∑–º–æ–∂–Ω–æ –ø–∞—Ä—Ç–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ —Å—Ç–∞—Ç—É—Å—É
- **Archive strategy**: –°—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–Ω–æ—Å—è—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–Ω—ã–µ –ø–∞—Ä—Ç–∏—Ü–∏–∏

## üöÄ Next Steps

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Database Schema & Migrations –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ **Phase 1.3: Basic API Gateway (Rust/Axum)** –∏–∑ hackathon-development-plan.md

### –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∞–∑–µ
- ‚úÖ –í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
- ‚úÖ –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–ª—è Rust –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
- ‚úÖ –ú–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
- ‚úÖ –ê—É–¥–∏—Ç –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∑–∞–ª–æ–∂–µ–Ω—ã –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É
- ‚úÖ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞

### Integration Points
- **Rust models**: sqlx –º–æ–¥–µ–ª–∏ –±—É–¥—É—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏–∑ —Å—Ö–µ–º—ã
- **API endpoints**: REST API –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ —Ç–∞–±–ª–∏—Ü—ã
- **Authentication**: JWT –∏ Web3 –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≥–æ—Ç–æ–≤–∞ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
- **Quantum crypto**: –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∫–ª—é—á–µ–π –≥–æ—Ç–æ–≤–∞
- **AI risk engine**: –î–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–∏—Å–∫–æ–≤ –¥–æ—Å—Ç—É–ø–Ω—ã