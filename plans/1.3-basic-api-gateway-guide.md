# KEMBridge Basic API Gateway (Rust/Axum) - Техническое руководство по реализации

## 📋 Обзор

Детальное руководство по реализации современного, высокопроизводительного API Gateway на Rust 1.88+ и Axum 0.8.4 для KEMBridge. Включает анализ последних возможностей языка, архитектурные решения и пошаговые инструкции реализации enterprise-grade решения.

## 🔍 Анализ технологического стека

### Rust 1.88+ (Latest Stable): Ключевые возможности для KEMBridge

#### 🚀 Async/Await Improvements

**Стратегические преимущества для API Gateway:**

- ✅ **Async closures stabilized**: Более элегантная работа с асинхронными callback'ами
- ✅ **AsyncFn\* traits**: Расширенные возможности для middleware и обработчиков
- ✅ **Improved Waker/Context APIs**: Лучшая производительность async runtime
- ✅ **Better const context**: Compile-time оптимизации для статических конфигураций

**Применение в KEMBridge:**

```rust
// Современный async middleware с Rust 1.88+
async fn quantum_auth_middleware<F>(req: Request, next: F) -> Response
where
    F: AsyncFn(Request) -> Response + Send + 'static,
{
    // Асинхронная проверка квантовых подписей
    let quantum_result = verify_quantum_signature(&req).await;
    match quantum_result {
        Ok(_) => next(req).await,
        Err(e) => error_response(e),
    }
}
```

#### 🔧 Let Chains & Pattern Matching

**Современный синтаксис для сложной валидации:**

```rust
// Rust 1.88+ let chains для валидации Web3 транзакций
if let Some(auth_header) = req.headers().get("authorization")
   && let Ok(token) = parse_jwt(auth_header)
   && let Some(wallet_addr) = extract_wallet_address(&token)
   && is_valid_ethereum_address(&wallet_addr) {
    // Обработка авторизованного запроса
    process_authenticated_request(req, wallet_addr).await
} else {
    unauthorized_response()
}
```

#### ⚡ Performance Improvements

**Критические оптимизации для high-load API:**

- ✅ **Next-generation trait solver**: Faster compilation для больших проектов
- ✅ **Improved sorting algorithms**: Driftsort/ipnsort для обработки больших JSON datasets
- ✅ **Enhanced WebAssembly support**: Готовность к edge computing deployment
- ✅ **Better target feature detection**: Оптимизация под конкретную архитектуру

### Axum 0.8+: Production-Ready Framework для Enterprise API

#### 🏗️ Архитектурные преимущества Axum для KEMBridge

**Стратегические решения:**

- ✅ **Zero-cost abstractions**: Максимальная производительность без overhead
- ✅ **Tower ecosystem integration**: Богатая экосистема middleware (CORS, auth, rate limiting)
- ✅ **Macro-free API**: Простота debugging и понятный code flow
- ✅ **Type-safe extractors**: Compile-time проверки всех request parameters
- ✅ **Built-in error handling**: Гарантированная обработка ошибок
- ✅ **WebSocket support**: Native поддержка real-time уведомлений

**Специфические преимущества для KEMBridge:**

- **Web3 integration**: Эффективная работа с JSON-RPC блокчейн запросами
- **Quantum crypto**: Высокая производительность для cryptographic operations
- **AI integration**: Асинхронные запросы к AI risk engine без блокировок
- **Cross-chain operations**: Concurrent обработка multiple blockchain requests

#### 🛡️ Security & Performance Features

**Enterprise-grade возможности:**

```rust
// Axum 0.8+ advanced middleware stack
let app = Router::new()
    .route("/api/v1/bridge/swap", post(handle_swap))
    .layer(
        ServiceBuilder::new()
            .layer(TraceLayer::new_for_http())                    // Distributed tracing
            .layer(CorsLayer::permissive())                       // CORS handling
            .layer(RequestBodyLimitLayer::new(1024 * 1024))       // 1MB request limit
            .layer(CompressionLayer::new())                       // Gzip compression
            .layer(RateLimitLayer::new(100, Duration::from_secs(60))) // Rate limiting
            .layer(AuthLayer::new(quantum_auth_handler))          // Quantum auth
    )
    .merge(SwaggerUi::new("/docs").url("/openapi.json", ApiDoc::openapi()))
    .with_state(app_state);
```

## 🏗️ Архитектура API Gateway для KEMBridge

### Модульная Rust Workspace структура

```
backend/
├── Cargo.toml                    # Workspace configuration
├── src/                          # Main API Gateway application
│   ├── main.rs                   # Entry point & server setup
│   ├── config.rs                 # Environment configuration
│   ├── routes/                   # Route definitions
│   │   ├── mod.rs
│   │   ├── health.rs             # Health check endpoints
│   │   ├── auth.rs               # Authentication routes
│   │   ├── bridge.rs             # Bridge operation routes
│   │   └── quantum.rs            # Quantum crypto routes
│   ├── middleware/               # Custom middleware
│   │   ├── mod.rs
│   │   ├── auth.rs               # Authentication middleware
│   │   ├── cors.rs               # CORS configuration
│   │   ├── rate_limit.rs         # Rate limiting
│   │   ├── quantum_security.rs   # Quantum signature verification
│   │   └── error_handler.rs      # Global error handling
│   ├── extractors/               # Custom request extractors
│   │   ├── mod.rs
│   │   ├── auth.rs               # JWT & Web3 extractors
│   │   ├── quantum.rs            # Quantum key extractors
│   │   └── validation.rs         # Request validation
│   ├── handlers/                 # Request handlers
│   │   ├── mod.rs
│   │   ├── health.rs             # Health check handlers
│   │   ├── auth.rs               # Authentication handlers
│   │   ├── bridge.rs             # Bridge operation handlers
│   │   └── quantum.rs            # Quantum crypto handlers
│   ├── models/                   # Request/Response models
│   │   ├── mod.rs
│   │   ├── auth.rs               # Authentication models
│   │   ├── bridge.rs             # Bridge operation models
│   │   ├── quantum.rs            # Quantum crypto models
│   │   └── errors.rs             # Error models
│   ├── services/                 # Business logic services
│   │   ├── mod.rs
│   │   ├── auth_service.rs       # Authentication logic
│   │   ├── bridge_service.rs     # Bridge coordination
│   │   ├── quantum_service.rs    # Quantum crypto operations
│   │   └── ai_service.rs         # AI risk engine client
│   └── utils/                    # Utility functions
│       ├── mod.rs
│       ├── crypto.rs             # Cryptographic utilities
│       ├── validation.rs         # Validation helpers
│       └── constants.rs          # Application constants
├── crates/                       # Domain-specific crates
│   ├── kembridge-auth/           # Web3 & OAuth authentication
│   ├── kembridge-crypto/         # Quantum cryptography
│   ├── kembridge-bridge/         # Cross-chain bridge logic
│   ├── kembridge-blockchain/     # Blockchain adapters
│   └── kembridge-database/       # Database layer
└── tests/                        # Integration tests
    ├── auth_tests.rs
    ├── bridge_tests.rs
    ├── quantum_tests.rs
    └── integration_tests.rs
```

### Advanced Cargo.toml Configuration

```toml
[workspace]
members = [
    "crates/kembridge-auth",
    "crates/kembridge-crypto",
    "crates/kembridge-bridge",
    "crates/kembridge-database",
    "crates/kembridge-blockchain",
]
resolver = "2"

[workspace.dependencies]
# Web framework (latest stable)
axum = { version = "0.8", features = ["ws", "macros", "tracing"] }
tokio = { version = "1.40", features = ["full"] }
tower = { version = "0.5", features = ["full"] }
tower-http = { version = "0.6", features = [
    "cors", "trace", "compression-gzip", "limit", "request-id", "sensitive-headers"
] }

# Database & Cache
sqlx = { version = "0.8", features = [
    "runtime-tokio-rustls", "postgres", "chrono", "uuid", "json", "migrate"
] }
redis = { version = "0.26", features = ["tokio-comp", "connection-manager"] }

# Serialization & JSON
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Authentication & Cryptography
jsonwebtoken = "9.3"
ring = "0.17"          # Modern crypto library
sha2 = "0.10"
secp256k1 = "0.29"
ed25519-dalek = "2.1"

# Post-quantum cryptography
pqcrypto = "0.19"
pqcrypto-kyber = "0.8"
ml-kem = "0.2"         # ML-KEM-1024 implementation

# HTTP client & networking
reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
hyper = { version = "1.4", features = ["full"] }

# Async & Concurrency
futures = "0.3"
async-trait = "0.1"

# Logging & Tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
tracing-opentelemetry = "0.25"

# Configuration & Environment
config = "0.14"
dotenvy = "0.15"

# Time & UUID
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.10", features = ["v4", "v7", "serde"] }

# Validation & Parsing
validator = { version = "0.18", features = ["derive"] }
url = "2.5"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Security & Rate limiting
tower-governor = "0.4"
headers = "0.4"

# Blockchain integration
ethers = "2.0"
near-sdk = "5.4"
near-jsonrpc-client = "0.12"

# Monitoring & Metrics
metrics = "0.23"
metrics-exporter-prometheus = "0.15"

# API Documentation
utoipa = "5.0.1"
utoipa-swagger-ui = "8.0.2"
utoipa-axum = "0.1.0"

# Development & Testing
rstest = "0.23"
mockall = "0.13"
wiremock = "0.6"

# KEMBridge internal crates
kembridge-auth = { path = "crates/kembridge-auth" }
kembridge-crypto = { path = "crates/kembridge-crypto" }
kembridge-bridge = { path = "crates/kembridge-bridge" }
kembridge-database = { path = "crates/kembridge-database" }
kembridge-blockchain = { path = "crates/kembridge-blockchain" }

# Main gateway binary
[package]
name = "kembridge-backend"
version = "0.1.0"
edition = "2021"
rust-version = "1.88"

[dependencies]
# Core framework
axum.workspace = true
tokio.workspace = true
tower.workspace = true
tower-http.workspace = true

# State management
sqlx.workspace = true
redis.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Configuration
dotenvy.workspace = true
config.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Error handling
anyhow.workspace = true
thiserror.workspace = true

# Validation
validator.workspace = true

# Time & UUID
chrono.workspace = true
uuid.workspace = true

# Security
tower-governor.workspace = true
headers.workspace = true

# Monitoring
metrics.workspace = true
metrics-exporter-prometheus.workspace = true

# Internal crates
kembridge-auth.workspace = true
kembridge-database.workspace = true
kembridge-crypto.workspace = true
kembridge-bridge.workspace = true
kembridge-blockchain.workspace = true

[features]
default = ["production"]
development = ["tracing-subscriber/env-filter"]
production = ["tower-http/compression-gzip"]
testing = ["mockall", "wiremock"]
```

## 🔧 Детальная реализация компонентов

### 1.3.1 Инициализация Axum проекта с современной архитектурой

#### Main Application Setup

```rust
// src/main.rs - Modern Rust 1.88+ setup
use axum::{
    http::{Method, StatusCode},
    middleware,
    response::Json,
    routing::{get, post},
    Router,
};
use std::net::SocketAddr;
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer,
    cors::{Any, CorsLayer},
    limit::RequestBodyLimitLayer,
    trace::TraceLayer,
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod config;
mod routes;
mod middleware;
mod handlers;
mod extractors;
mod models;
mod services;
mod utils;

use config::AppConfig;
use middleware::{auth::auth_middleware, error_handler::handle_error};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize comprehensive tracing
    init_tracing()?;

    // Load configuration from environment
    let config = AppConfig::from_env()?;

    // Initialize database connections
    let db_pool = kembridge_database::create_pool(&config.database_url).await?;
    kembridge_database::run_migrations(&db_pool).await?;

    // Initialize Redis connection manager
    let redis_manager = redis::ConnectionManager::new(
        redis::Client::open(config.redis_url.as_str())?
    ).await?;

    // Create application state
    let app_state = AppState::new(db_pool, redis_manager, config.clone()).await?;

    // Build application with comprehensive middleware stack
    let app = create_application(app_state).await?;

    // Start server with graceful shutdown
    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    tracing::info!("🚀 KEMBridge API Gateway starting on {}", addr);
    tracing::info!("📋 Health check available at http://{}/health", addr);
    tracing::info!("📖 API documentation at http://{}/docs", addr);

    // Graceful shutdown handling
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn create_application(state: AppState) -> anyhow::Result<Router> {
    let app = Router::new()
        // Health & Status endpoints
        .route("/health", get(handlers::health::health_check))
        .route("/ready", get(handlers::health::readiness_check))
        .route("/metrics", get(handlers::health::metrics))

        // API v1 routes
        .nest("/api/v1", create_v1_routes())

        // WebSocket for real-time updates
        .route("/ws", get(handlers::websocket::websocket_handler))

        // Global middleware stack (applied in reverse order)
        .layer(
            ServiceBuilder::new()
                // Outermost: Error handling
                .layer(middleware::from_fn(handle_error))

                // Security & CORS
                .layer(create_cors_layer()?)

                // Request processing
                .layer(RequestBodyLimitLayer::new(1024 * 1024)) // 1MB limit
                .layer(CompressionLayer::new())

                // Observability
                .layer(
                    TraceLayer::new_for_http()
                        .make_span_with(middleware::trace::make_span)
                        .on_request(middleware::trace::on_request)
                        .on_response(middleware::trace::on_response)
                )

                // Rate limiting (applied per route)
                .layer(middleware::from_fn(middleware::rate_limit::rate_limit))
        )

        // Attach application state
        .with_state(state);

    Ok(app)
}

fn create_v1_routes() -> Router<AppState> {
    Router::new()
        // Authentication routes
        .nest("/auth", routes::auth::create_routes())

        // Bridge operation routes
        .nest("/bridge", routes::bridge::create_routes())

        // Quantum cryptography routes
        .nest("/quantum", routes::quantum::create_routes())

        // User management routes
        .nest("/user", routes::user::create_routes())

        // Admin routes (protected)
        .nest("/admin", routes::admin::create_routes())

        // Authentication middleware for protected routes
        .layer(middleware::from_fn_with_state(
            (), // State for middleware
            auth_middleware
        ))
}

fn create_cors_layer() -> anyhow::Result<CorsLayer> {
    let cors = CorsLayer::new()
        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE, Method::OPTIONS])
        .allow_headers([
            "content-type",
            "authorization",
            "x-quantum-signature",
            "x-wallet-address",
            "x-request-id"
        ])
        .allow_origin(Any) // Configure based on environment
        .allow_credentials(true);

    Ok(cors)
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            tracing::info!("🛑 Ctrl+C received, shutting down gracefully...");
        },
        _ = terminate => {
            tracing::info!("🛑 SIGTERM received, shutting down gracefully...");
        },
    }
}

fn init_tracing() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "kembridge_backend=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer().json())
        .init();

    Ok(())
}
```

#### Advanced Application State Management

```rust
// Application state with dependency injection
#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
    pub redis: redis::ConnectionManager,
    pub config: AppConfig,
    pub auth_service: Arc<services::AuthService>,
    pub bridge_service: Arc<services::BridgeService>,
    pub quantum_service: Arc<services::QuantumService>,
    pub ai_client: Arc<services::AiClient>,
    pub metrics: Arc<metrics::Registry>,
}

impl AppState {
    pub async fn new(
        db: sqlx::PgPool,
        redis: redis::ConnectionManager,
        config: AppConfig,
    ) -> anyhow::Result<Self> {
        // Initialize services with dependency injection
        let auth_service = Arc::new(
            services::AuthService::new(db.clone(), redis.clone(), &config).await?
        );

        let quantum_service = Arc::new(
            services::QuantumService::new(db.clone(), &config).await?
        );

        let bridge_service = Arc::new(
            services::BridgeService::new(
                db.clone(),
                quantum_service.clone(),
                &config
            ).await?
        );

        let ai_client = Arc::new(
            services::AiClient::new(&config.ai_engine_url)?
        );

        let metrics = Arc::new(metrics::Registry::new());

        Ok(Self {
            db,
            redis,
            config,
            auth_service,
            bridge_service,
            quantum_service,
            ai_client,
            metrics,
        })
    }
}
```

### 1.3.2 Advanced CORS Configuration

```rust
// src/middleware/cors.rs - Production-ready CORS setup
use axum::http::{HeaderValue, Method};
use tower_http::cors::{CorsLayer, AllowOrigin};
use crate::config::AppConfig;

pub fn create_production_cors(config: &AppConfig) -> CorsLayer {
    let allowed_origins: Vec<HeaderValue> = config
        .cors_origins
        .iter()
        .filter_map(|origin| origin.parse().ok())
        .collect();

    CorsLayer::new()
        .allow_origin(AllowOrigin::list(allowed_origins))
        .allow_methods([
            Method::GET,
            Method::POST,
            Method::PUT,
            Method::DELETE,
            Method::PATCH,
            Method::OPTIONS,
        ])
        .allow_headers([
            "content-type",
            "authorization",
            "x-quantum-signature",
            "x-wallet-address",
            "x-request-id",
            "x-user-agent",
            "x-forwarded-for",
        ])
        .allow_credentials(true)
        .max_age(std::time::Duration::from_secs(3600))
}

pub fn create_development_cors() -> CorsLayer {
    CorsLayer::permissive()
}
```

### 1.3.3 PostgreSQL Integration через SQLx

```rust
// src/services/database.rs - Advanced PostgreSQL 18 integration
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub struct DatabaseService {
    pool: PgPool,
}

impl DatabaseService {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    // PostgreSQL 18 UUIDv7 integration
    pub async fn generate_uuidv7(&self) -> sqlx::Result<Uuid> {
        let row = sqlx::query("SELECT generate_uuidv7() as id")
            .fetch_one(&self.pool)
            .await?;

        Ok(row.get("id"))
    }

    // Advanced transaction with quantum key integration
    pub async fn create_bridge_transaction(
        &self,
        user_id: Uuid,
        source_chain: &str,
        dest_chain: &str,
        amount: rust_decimal::Decimal,
        quantum_key_id: Option<Uuid>,
    ) -> sqlx::Result<Uuid> {
        let mut tx = self.pool.begin().await?;

        // Use PostgreSQL 18 function
        let transaction_id = sqlx::query_scalar!(
            r#"
            SELECT create_bridge_transaction(
                $1, $2, $3, 'ETH', 'NEAR', $4, NULL, $5, 24, NULL
            ) as "transaction_id!"
            "#,
            user_id,
            source_chain,
            dest_chain,
            amount,
            quantum_key_id
        )
        .fetch_one(&mut *tx)
        .await?;

        tx.commit().await?;
        Ok(transaction_id)
    }

    // Efficient JSON queries with PostgreSQL 18 SIMD optimization
    pub async fn get_user_risk_profile(&self, user_id: Uuid) -> sqlx::Result<serde_json::Value> {
        let risk_profile = sqlx::query_scalar!(
            r#"
            SELECT risk_profile
            FROM users
            WHERE id = $1 AND is_active = true
            "#,
            user_id
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(risk_profile.unwrap_or_else(|| serde_json::json!({"score": 0.0})))
    }
}
```

### 1.3.4 Redis Integration для кеширования

```rust
// src/services/cache.rs - Advanced Redis integration
use redis::{aio::ConnectionManager, AsyncCommands, RedisResult};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct CacheService {
    manager: ConnectionManager,
}

impl CacheService {
    pub fn new(manager: ConnectionManager) -> Self {
        Self { manager }
    }

    // Generic cache operations with serialization
    pub async fn set_json<T>(&self, key: &str, value: &T, ttl: Duration) -> RedisResult<()>
    where
        T: Serialize,
    {
        let mut conn = self.manager.clone();
        let serialized = serde_json::to_string(value)
            .map_err(|e| redis::RedisError::from((redis::ErrorKind::TypeError, "Serialization failed", e.to_string())))?;

        conn.set_ex(key, serialized, ttl.as_secs()).await
    }

    pub async fn get_json<T>(&self, key: &str) -> RedisResult<Option<T>>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut conn = self.manager.clone();
        let value: Option<String> = conn.get(key).await?;

        match value {
            Some(serialized) => {
                let deserialized = serde_json::from_str(&serialized)
                    .map_err(|e| redis::RedisError::from((redis::ErrorKind::TypeError, "Deserialization failed", e.to_string())))?;
                Ok(Some(deserialized))
            },
            None => Ok(None),
        }
    }

    // Session management
    pub async fn store_session(&self, session_id: &str, user_id: Uuid, ttl: Duration) -> RedisResult<()> {
        let mut conn = self.manager.clone();
        let session_data = serde_json::json!({
            "user_id": user_id,
            "created_at": chrono::Utc::now(),
        });

        conn.set_ex(
            format!("session:{}", session_id),
            session_data.to_string(),
            ttl.as_secs()
        ).await
    }

    // Rate limiting with sliding window
    pub async fn check_rate_limit(&self, key: &str, limit: u32, window: Duration) -> RedisResult<bool> {
        let mut conn = self.manager.clone();
        let now = chrono::Utc::now().timestamp();
        let window_start = now - window.as_secs() as i64;

        // Remove expired entries
        let _: () = conn.zremrangebyscore(key, 0, window_start).await?;

        // Count current requests
        let count: u32 = conn.zcard(key).await?;

        if count >= limit {
            return Ok(false);
        }

        // Add current request
        let _: () = conn.zadd(key, now, format!("req:{}", uuid::Uuid::new_v4())).await?;
        let _: () = conn.expire(key, window.as_secs()).await?;

        Ok(true)
    }
}
```

### 1.3.5 Advanced Route Handlers

```rust
// src/handlers/health.rs - Comprehensive health checks
use axum::{extract::State, response::Json, http::StatusCode};
use serde_json::{json, Value};

pub async fn health_check(State(state): State<AppState>) -> Result<Json<Value>, StatusCode> {
    Ok(Json(json!({
        "status": "healthy",
        "service": "kembridge-api-gateway",
        "version": env!("CARGO_PKG_VERSION"),
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "rust_version": env!("RUSTC_VERSION"),
        "features": {
            "quantum_crypto": true,
            "ai_risk_engine": true,
            "cross_chain_bridge": true,
            "web3_auth": true
        }
    })))
}

pub async fn readiness_check(State(state): State<AppState>) -> Result<Json<Value>, StatusCode> {
    // Check database connectivity
    let db_status = match sqlx::query("SELECT 1").fetch_one(&state.db).await {
        Ok(_) => "healthy",
        Err(_) => "unhealthy",
    };

    // Check Redis connectivity
    let redis_status = match state.redis.clone().get::<_, Option<String>>("health_check").await {
        Ok(_) => "healthy",
        Err(_) => "unhealthy",
    };

    let overall_status = if db_status == "healthy" && redis_status == "healthy" {
        "ready"
    } else {
        "not_ready"
    };

    let status_code = if overall_status == "ready" {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };

    Ok(Json(json!({
        "status": overall_status,
        "components": {
            "database": {
                "status": db_status,
                "type": "postgresql-18"
            },
            "cache": {
                "status": redis_status,
                "type": "redis"
            },
            "quantum_crypto": {
                "status": "healthy",
                "algorithm": "ml-kem-1024"
            }
        },
        "timestamp": chrono::Utc::now().to_rfc3339()
    })))
}

pub async fn metrics(State(state): State<AppState>) -> Result<String, StatusCode> {
    // Export Prometheus metrics
    use metrics_exporter_prometheus::PrometheusHandle;

    let handle = metrics_exporter_prometheus::PrometheusBuilder::new()
        .build_recorder()
        .handle();

    Ok(handle.render())
}
```

### 1.3.6 Advanced Tracing & Logging

```rust
// src/middleware/trace.rs - Comprehensive observability
use axum::http::{Request, Response};
use tracing::{info_span, Span};
use uuid::Uuid;

pub fn make_span<B>(request: &Request<B>) -> Span {
    let request_id = Uuid::new_v4();

    info_span!(
        "http_request",
        method = %request.method(),
        uri = %request.uri(),
        version = ?request.version(),
        request_id = %request_id,
        user_agent = request.headers()
            .get("user-agent")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown"),
        quantum_signature = request.headers()
            .contains_key("x-quantum-signature"),
        wallet_address = request.headers()
            .get("x-wallet-address")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("anonymous"),
    )
}

pub fn on_request<B>(request: &Request<B>, _span: &Span) {
    tracing::info!("🔄 Processing request");
}

pub fn on_response<B>(response: &Response<B>, latency: std::time::Duration, _span: &Span) {
    tracing::info!(
        "✅ Request completed",
        status = %response.status(),
        latency_ms = latency.as_millis(),
    );
}
```

### 1.3.7 Advanced Error Handling

```rust
// src/middleware/error_handler.rs - Comprehensive error handling
use axum::{
    http::StatusCode,
    response::{Json, Response},
    middleware::Next,
    extract::Request,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ApiError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("Redis error: {0}")]
    Redis(#[from] redis::RedisError),

    #[error("Authentication failed: {0}")]
    Authentication(String),

    #[error("Quantum signature verification failed")]
    QuantumSignature,

    #[error("Bridge operation failed: {0}")]
    Bridge(String),

    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Internal server error")]
    Internal,
}

impl From<ApiError> for Response {
    fn from(error: ApiError) -> Self {
        let (status, code, message) = match error {
            ApiError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "DATABASE_ERROR", "Database operation failed"),
            ApiError::Redis(_) => (StatusCode::INTERNAL_SERVER_ERROR, "CACHE_ERROR", "Cache operation failed"),
            ApiError::Authentication(msg) => (StatusCode::UNAUTHORIZED, "AUTH_FAILED", &msg),
            ApiError::QuantumSignature => (StatusCode::UNAUTHORIZED, "QUANTUM_SIGNATURE_INVALID", "Quantum signature verification failed"),
            ApiError::Bridge(msg) => (StatusCode::BAD_REQUEST, "BRIDGE_ERROR", &msg),
            ApiError::RateLimit => (StatusCode::TOO_MANY_REQUESTS, "RATE_LIMIT_EXCEEDED", "Too many requests"),
            ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, "VALIDATION_ERROR", &msg),
            ApiError::Internal => (StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR", "Internal server error"),
        };

        let body = Json(json!({
            "error": {
                "code": code,
                "message": message,
                "timestamp": chrono::Utc::now().to_rfc3339(),
            }
        }));

        (status, body).into_response()
    }
}

pub async fn handle_error(request: Request, next: Next) -> Response {
    let response = next.run(request).await;

    // Add error correlation ID for tracking
    if response.status().is_client_error() || response.status().is_server_error() {
        tracing::error!(
            "❌ Request failed with status: {}",
            response.status()
        );
    }

    response
}
```

### 1.3.8 Modern Data Structures with OpenAPI Documentation

```rust
// src/models/mod.rs - Type-safe request/response models with OpenAPI generation
use serde::{Deserialize, Serialize};
use validator::Validate;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use utoipa::{ToSchema, OpenApi};
use utoipa_swagger_ui::{SwaggerUi, Url};

#[derive(Debug, Serialize, Deserialize, Validate, ToSchema)]
pub struct BridgeSwapRequest {
    #[validate(length(min = 1, max = 20))]
    pub source_chain: String,

    #[validate(length(min = 1, max = 20))]
    pub destination_chain: String,

    #[validate(length(min = 1, max = 10))]
    pub source_token: String,

    #[validate(length(min = 1, max = 10))]
    pub destination_token: String,

    #[validate(range(min = 0.000001))]
    pub amount: f64,

    pub quantum_key_id: Option<Uuid>,

    #[validate(range(min = 1, max = 168))] // 1 hour to 1 week
    pub expires_in_hours: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct BridgeSwapResponse {
    pub transaction_id: Uuid,
    pub status: TransactionStatus,
    pub estimated_completion: DateTime<Utc>,
    pub bridge_fee: f64,
    pub network_fee: f64,
    pub quantum_protection_fee: f64,
    pub exchange_rate: f64,
    pub expected_output: f64,
    pub risk_score: f64,
    pub quantum_protected: bool,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TransactionStatus {
    Pending,
    Validating,
    Locked,
    Processing,
    Confirming,
    Confirmed,
    Completed,
    Failed,
    Cancelled,
    Expired,
    Refunded,
}

#[derive(Debug, Serialize, Deserialize, Validate, ToSchema)]
pub struct AuthRequest {
    #[validate(length(min = 42, max = 42))] // Ethereum address length
    pub wallet_address: String,

    #[validate(length(min = 1))]
    pub signature: String,

    #[validate(length(min = 1))]
    pub message: String,

    #[validate(length(min = 1, max = 20))]
    pub chain_type: String,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct AuthResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    pub expires_in: u64,
    pub user_id: Uuid,
    pub wallet_address: String,
    pub quantum_keys_available: bool,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct QuantumKeyPair {
    pub key_id: Uuid,
    pub public_key: String,
    pub algorithm: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub key_strength: String,
    pub usage_category: String,
}
```

## 📊 Performance & Security Considerations

### High-Performance Configuration

```rust
// Performance optimizations for production
[profile.release]
lto = true              # Link-time optimization
codegen-units = 1       # Single codegen unit for better optimization
panic = "abort"         # Smaller binary size
strip = true           # Strip symbols

[profile.release.package.kembridge-crypto]
opt-level = 3          # Maximum optimization for crypto operations
```

### Security Headers & Middleware

```rust
// Security middleware stack
use tower_http::set_header::SetResponseHeaderLayer;
use axum::http::header;

pub fn security_headers() -> SetResponseHeaderLayer<HeaderValue> {
    ServiceBuilder::new()
        .layer(SetResponseHeaderLayer::overriding(
            header::X_CONTENT_TYPE_OPTIONS,
            HeaderValue::from_static("nosniff"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::X_FRAME_OPTIONS,
            HeaderValue::from_static("DENY"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::X_XSS_PROTECTION,
            HeaderValue::from_static("1; mode=block"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::STRICT_TRANSPORT_SECURITY,
            HeaderValue::from_static("max-age=31536000; includeSubDomains"),
        ))
}
```

## 🎯 Чекпоинт реализации 1.3

После завершения всех 8 подпунктов система должна:

### ✅ Полностью функциональный API Gateway

- **Axum 0.8+ backend** работает в Docker контейнере
- **PostgreSQL 18** подключение через SQLx с UUIDv7 поддержкой
- **Redis** интеграция для кеширования и сессий
- **Comprehensive middleware** stack с CORS, rate limiting, tracing
- **Type-safe extractors** для всех request/response данных
- **Advanced error handling** с structured logging
- **Health checks** для monitoring готовности сервиса
- **WebSocket support** для real-time уведомлений

### 🔗 API Endpoints Ready

```bash
# Health checks
GET  /health          # Service health
GET  /ready           # Readiness probe
GET  /metrics         # Prometheus metrics

# Authentication (Phase 2.1)
POST /api/v1/auth/nonce      # Generate nonce for signing
POST /api/v1/auth/verify     # Verify Web3 signature
POST /api/v1/auth/refresh    # Refresh JWT token

# Bridge operations (Phase 4.3)
POST /api/v1/bridge/swap     # Initiate cross-chain swap
GET  /api/v1/bridge/status/{id} # Get transaction status
GET  /api/v1/bridge/quote    # Get swap quote

# Quantum crypto (Phase 3.2)
POST /api/v1/quantum/generate # Generate quantum key pair
POST /api/v1/quantum/encrypt  # Encrypt data
POST /api/v1/quantum/decrypt  # Decrypt data

# WebSocket
WS   /ws              # Real-time updates
```

### 🚀 Ready for Phase 2: Authentication & Authorization

Solid foundation готов для интеграции:

- Web3 signature verification (Phase 2.1)
- JWT session management (Phase 2.2)
- Quantum cryptography integration (Phase 3.1)
- Cross-chain bridge logic (Phase 4.1)

**Технологический стек полностью ready:**

- Rust 1.88+ с async/await improvements
- Axum 0.8+ с production-grade middleware
- PostgreSQL 18 с UUIDv7 и JSONB optimization
- Redis для high-performance caching
- OpenAPI/Swagger UI для интерактивной документации
- Comprehensive observability с OpenTelemetry

Переходим к следующему этапу - **Phase 2.1: Web3 Authentication Service**!

## 📖 OpenAPI/Swagger Documentation Integration

### Comprehensive API Documentation with utoipa

```rust
// src/openapi.rs - OpenAPI schema definition
use utoipa::{OpenApi, Modify};
use crate::models::*;

#[derive(OpenApi)]
#[openapi(
    paths(
        crate::handlers::health::health_check,
        crate::handlers::health::readiness_check,
        crate::handlers::auth::generate_nonce,
        crate::handlers::auth::verify_signature,
        crate::handlers::bridge::initiate_swap,
        crate::handlers::bridge::get_swap_status,
        crate::handlers::quantum::generate_keypair,
    ),
    components(
        schemas(
            BridgeSwapRequest,
            BridgeSwapResponse,
            TransactionStatus,
            AuthRequest,
            AuthResponse,
            QuantumKeyPair,
            ErrorResponse,
            HealthStatus,
        )
    ),
    modifiers(&SecurityAddon),
    tags(
        (name = "Health", description = "Health check endpoints"),
        (name = "Authentication", description = "Web3 wallet authentication"),
        (name = "Bridge", description = "Cross-chain bridge operations"),
        (name = "Quantum", description = "Post-quantum cryptography operations"),
    ),
    info(
        title = "KEMBridge API",
        version = "1.0.0",
        description = "Quantum-secure cross-chain bridge API",
        contact(
            name = "KEMBridge Team",
            email = "support@kembridge.io",
        ),
        license(
            name = "MIT",
            url = "https://opensource.org/licenses/MIT",
        ),
    ),
    servers(
        (url = "http://localhost:3000", description = "Development server"),
        (url = "https://api.kembridge.io", description = "Production server"),
    ),
)]
pub struct ApiDoc;

struct SecurityAddon;

impl Modify for SecurityAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        use utoipa::openapi::security::*;
        
        let mut security_schemes = utoipa::openapi::security::SecuritySchemes::new();
        security_schemes.insert(
            "bearerAuth",
            SecurityScheme::Http(Http::new(HttpAuthScheme::Bearer))
        );
        
        openapi.components = Some(
            utoipa::openapi::ComponentsBuilder::new()
                .security_schemes(security_schemes)
                .build()
        );
    }
}
```

### Handler Documentation Examples

```rust
// src/handlers/bridge.rs - Documented API handlers
use axum::{extract::State, Json, response::Json as ResponseJson};
use utoipa::path;
use crate::{AppState, models::*};

/// Initiate cross-chain swap
#[utoipa::path(
    post,
    path = "/api/v1/bridge/swap",
    request_body = BridgeSwapRequest,
    responses(
        (status = 200, description = "Swap initiated successfully", body = BridgeSwapResponse),
        (status = 400, description = "Invalid request parameters", body = ErrorResponse),
        (status = 401, description = "Authentication required", body = ErrorResponse),
        (status = 402, description = "Insufficient balance", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
    ),
    security(
        ("bearerAuth" = [])
    ),
    tag = "Bridge"
)]
pub async fn initiate_swap(
    State(state): State<AppState>,
    Json(request): Json<BridgeSwapRequest>,
) -> Result<ResponseJson<BridgeSwapResponse>, AppError> {
    // Implementation here...
    todo!()
}

/// Get swap transaction status
#[utoipa::path(
    get,
    path = "/api/v1/bridge/status/{transaction_id}",
    params(
        ("transaction_id" = String, Path, description = "Transaction UUID")
    ),
    responses(
        (status = 200, description = "Transaction status retrieved", body = BridgeSwapResponse),
        (status = 404, description = "Transaction not found", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
    ),
    security(
        ("bearerAuth" = [])
    ),
    tag = "Bridge"
)]
pub async fn get_swap_status(
    State(state): State<AppState>,
    Path(transaction_id): Path<String>,
) -> Result<ResponseJson<BridgeSwapResponse>, AppError> {
    // Implementation here...
    todo!()
}
```

### Interactive Swagger UI Integration

```rust
// src/main.rs - Updated with Swagger UI
use utoipa_swagger_ui::SwaggerUi;
use crate::openapi::ApiDoc;

pub fn create_router(state: AppState) -> Router {
    let api_routes = Router::new()
        .route("/health", get(handlers::health::health_check))
        .route("/ready", get(handlers::health::readiness_check))
        .nest("/api/v1", api_v1_routes())
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CorsLayer::permissive())
                .layer(RequestBodyLimitLayer::new(1024 * 1024))
                .layer(CompressionLayer::new())
                .layer(RateLimitLayer::new(100, Duration::from_secs(60)))
                .layer(AuthLayer::new(quantum_auth_handler))
        );

    Router::new()
        .merge(api_routes)
        // Swagger UI integration
        .merge(
            SwaggerUi::new("/docs")
                .url("/openapi.json", ApiDoc::openapi())
                .config(
                    utoipa_swagger_ui::Config::new(["/openapi.json"])
                        .try_it_out_enabled(true)
                        .filter(true)
                        .show_extensions(true)
                )
        )
        // Raw OpenAPI JSON for API clients
        .route(
            "/openapi.json",
            get(|| async { Json(ApiDoc::openapi()) })
        )
        .with_state(state)
}
```

### Error Response Schema

```rust
// src/models/error.rs - Structured error responses
#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub details: Option<serde_json::Value>,
    pub timestamp: DateTime<Utc>,
    pub request_id: String,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ValidationError {
    pub field: String,
    pub message: String,
    pub value: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct HealthStatus {
    pub status: String,
    pub version: String,
    pub timestamp: DateTime<Utc>,
    pub services: HashMap<String, ServiceHealth>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ServiceHealth {
    pub status: String,
    pub response_time_ms: u64,
    pub last_check: DateTime<Utc>,
}
```

### API Documentation Features

**🔍 Автоматическая генерация документации:**
- ✅ **Interactive Swagger UI** по адресу `/docs`
- ✅ **OpenAPI 3.0 JSON** схема по адресу `/openapi.json`
- ✅ **Type-safe request/response** модели с валидацией
- ✅ **Authentication схемы** с JWT Bearer tokens
- ✅ **Error handling** с подробными HTTP status codes
- ✅ **Code generation support** для клиентских библиотек

**📊 Production-ready возможности:**
- ✅ **Multiple environments** (dev, staging, production)
- ✅ **API versioning** поддержка
- ✅ **Security definitions** для всех protected endpoints
- ✅ **Request/Response examples** для каждого endpoint
- ✅ **Parameter validation** с описанием constraints

**🚀 Developer Experience:**
- ✅ **Try it out** функциональность в браузере
- ✅ **curl команды** автогенерация
- ✅ **SDK generation** для популярных языков
- ✅ **API testing** прямо из документации
- ✅ **Filtering и search** по endpoints
