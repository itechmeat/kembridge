# KEMBridge Basic API Gateway (Rust/Axum) - –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

## üìã –û–±–∑–æ—Ä

–î–µ—Ç–∞–ª—å–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ, –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ API Gateway –Ω–∞ Rust 1.88+ –∏ Axum 0.8.4 –¥–ª—è KEMBridge. –í–∫–ª—é—á–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —è–∑—ã–∫–∞, –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –∏ –ø–æ—à–∞–≥–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ enterprise-grade —Ä–µ—à–µ–Ω–∏—è.

## üîç –ê–Ω–∞–ª–∏–∑ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ —Å—Ç–µ–∫–∞

### Rust 1.88+ (Latest Stable): –ö–ª—é—á–µ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è KEMBridge

#### üöÄ Async/Await Improvements

**–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –¥–ª—è API Gateway:**

- ‚úÖ **Async closures stabilized**: –ë–æ–ª–µ–µ —ç–ª–µ–≥–∞–Ω—Ç–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º–∏ callback'–∞–º–∏
- ‚úÖ **AsyncFn\* traits**: –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è middleware –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
- ‚úÖ **Improved Waker/Context APIs**: –õ—É—á—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å async runtime
- ‚úÖ **Better const context**: Compile-time –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π

**–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ KEMBridge:**

```rust
// –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π async middleware —Å Rust 1.88+
async fn quantum_auth_middleware<F>(req: Request, next: F) -> Response
where
    F: AsyncFn(Request) -> Response + Send + 'static,
{
    // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å–µ–π
    let quantum_result = verify_quantum_signature(&req).await;
    match quantum_result {
        Ok(_) => next(req).await,
        Err(e) => error_response(e),
    }
}
```

#### üîß Let Chains & Pattern Matching

**–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è —Å–ª–æ–∂–Ω–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏:**

```rust
// Rust 1.88+ let chains –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ Web3 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
if let Some(auth_header) = req.headers().get("authorization")
   && let Ok(token) = parse_jwt(auth_header)
   && let Some(wallet_addr) = extract_wallet_address(&token)
   && is_valid_ethereum_address(&wallet_addr) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    process_authenticated_request(req, wallet_addr).await
} else {
    unauthorized_response()
}
```

#### ‚ö° Performance Improvements

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è high-load API:**

- ‚úÖ **Next-generation trait solver**: Faster compilation –¥–ª—è –±–æ–ª—å—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤
- ‚úÖ **Improved sorting algorithms**: Driftsort/ipnsort –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–æ–ª—å—à–∏—Ö JSON datasets
- ‚úÖ **Enhanced WebAssembly support**: –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ edge computing deployment
- ‚úÖ **Better target feature detection**: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É

### Axum 0.8+: Production-Ready Framework –¥–ª—è Enterprise API

#### üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ Axum –¥–ª—è KEMBridge

**–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è:**

- ‚úÖ **Zero-cost abstractions**: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–µ–∑ overhead
- ‚úÖ **Tower ecosystem integration**: –ë–æ–≥–∞—Ç–∞—è —ç–∫–æ—Å–∏—Å—Ç–µ–º–∞ middleware (CORS, auth, rate limiting)
- ‚úÖ **Macro-free API**: –ü—Ä–æ—Å—Ç–æ—Ç–∞ debugging –∏ –ø–æ–Ω—è—Ç–Ω—ã–π code flow
- ‚úÖ **Type-safe extractors**: Compile-time –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö request parameters
- ‚úÖ **Built-in error handling**: –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- ‚úÖ **WebSocket support**: Native –ø–æ–¥–¥–µ—Ä–∂–∫–∞ real-time —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π

**–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –¥–ª—è KEMBridge:**

- **Web3 integration**: –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å JSON-RPC –±–ª–æ–∫—á–µ–π–Ω –∑–∞–ø—Ä–æ—Å–∞–º–∏
- **Quantum crypto**: –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è cryptographic operations
- **AI integration**: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –∫ AI risk engine –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
- **Cross-chain operations**: Concurrent –æ–±—Ä–∞–±–æ—Ç–∫–∞ multiple blockchain requests

#### üõ°Ô∏è Security & Performance Features

**Enterprise-grade –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**

```rust
// Axum 0.8+ advanced middleware stack
let app = Router::new()
    .route("/api/v1/bridge/swap", post(handle_swap))
    .layer(
        ServiceBuilder::new()
            .layer(TraceLayer::new_for_http())                    // Distributed tracing
            .layer(CorsLayer::permissive())                       // CORS handling
            .layer(RequestBodyLimitLayer::new(1024 * 1024))       // 1MB request limit
            .layer(CompressionLayer::new())                       // Gzip compression
            .layer(RateLimitLayer::new(100, Duration::from_secs(60))) // Rate limiting
            .layer(AuthLayer::new(quantum_auth_handler))          // Quantum auth
    )
    .merge(SwaggerUi::new("/docs").url("/openapi.json", ApiDoc::openapi()))
    .with_state(app_state);
```

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ API Gateway –¥–ª—è KEMBridge

### –ú–æ–¥—É–ª—å–Ω–∞—è Rust Workspace —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```
backend/
‚îú‚îÄ‚îÄ Cargo.toml                    # Workspace configuration
‚îú‚îÄ‚îÄ src/                          # Main API Gateway application
‚îÇ   ‚îú‚îÄ‚îÄ main.rs                   # Entry point & server setup
‚îÇ   ‚îú‚îÄ‚îÄ config.rs                 # Environment configuration
‚îÇ   ‚îú‚îÄ‚îÄ routes/                   # Route definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.rs             # Health check endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs               # Authentication routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge.rs             # Bridge operation routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ quantum.rs            # Quantum crypto routes
‚îÇ   ‚îú‚îÄ‚îÄ middleware/               # Custom middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs               # Authentication middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cors.rs               # CORS configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rate_limit.rs         # Rate limiting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quantum_security.rs   # Quantum signature verification
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error_handler.rs      # Global error handling
‚îÇ   ‚îú‚îÄ‚îÄ extractors/               # Custom request extractors
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs               # JWT & Web3 extractors
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quantum.rs            # Quantum key extractors
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.rs         # Request validation
‚îÇ   ‚îú‚îÄ‚îÄ handlers/                 # Request handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.rs             # Health check handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs               # Authentication handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge.rs             # Bridge operation handlers
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ quantum.rs            # Quantum crypto handlers
‚îÇ   ‚îú‚îÄ‚îÄ models/                   # Request/Response models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs               # Authentication models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge.rs             # Bridge operation models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quantum.rs            # Quantum crypto models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.rs             # Error models
‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.rs       # Authentication logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bridge_service.rs     # Bridge coordination
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quantum_service.rs    # Quantum crypto operations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ai_service.rs         # AI risk engine client
‚îÇ   ‚îî‚îÄ‚îÄ utils/                    # Utility functions
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îú‚îÄ‚îÄ crypto.rs             # Cryptographic utilities
‚îÇ       ‚îú‚îÄ‚îÄ validation.rs         # Validation helpers
‚îÇ       ‚îî‚îÄ‚îÄ constants.rs          # Application constants
‚îú‚îÄ‚îÄ crates/                       # Domain-specific crates
‚îÇ   ‚îú‚îÄ‚îÄ kembridge-auth/           # Web3 & OAuth authentication
‚îÇ   ‚îú‚îÄ‚îÄ kembridge-crypto/         # Quantum cryptography
‚îÇ   ‚îú‚îÄ‚îÄ kembridge-bridge/         # Cross-chain bridge logic
‚îÇ   ‚îú‚îÄ‚îÄ kembridge-blockchain/     # Blockchain adapters
‚îÇ   ‚îî‚îÄ‚îÄ kembridge-database/       # Database layer
‚îî‚îÄ‚îÄ tests/                        # Integration tests
    ‚îú‚îÄ‚îÄ auth_tests.rs
    ‚îú‚îÄ‚îÄ bridge_tests.rs
    ‚îú‚îÄ‚îÄ quantum_tests.rs
    ‚îî‚îÄ‚îÄ integration_tests.rs
```

### Advanced Cargo.toml Configuration

```toml
[workspace]
members = [
    "crates/kembridge-auth",
    "crates/kembridge-crypto",
    "crates/kembridge-bridge",
    "crates/kembridge-database",
    "crates/kembridge-blockchain",
]
resolver = "2"

[workspace.dependencies]
# Web framework (latest stable)
axum = { version = "0.8", features = ["ws", "macros", "tracing"] }
tokio = { version = "1.40", features = ["full"] }
tower = { version = "0.5", features = ["full"] }
tower-http = { version = "0.6", features = [
    "cors", "trace", "compression-gzip", "limit", "request-id", "sensitive-headers"
] }

# Database & Cache
sqlx = { version = "0.8", features = [
    "runtime-tokio-rustls", "postgres", "chrono", "uuid", "json", "migrate"
] }
redis = { version = "0.26", features = ["tokio-comp", "connection-manager"] }

# Serialization & JSON
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Authentication & Cryptography
jsonwebtoken = "9.3"
ring = "0.17"          # Modern crypto library
sha2 = "0.10"
secp256k1 = "0.29"
ed25519-dalek = "2.1"

# Post-quantum cryptography
pqcrypto = "0.19"
pqcrypto-kyber = "0.8"
ml-kem = "0.2"         # ML-KEM-1024 implementation

# HTTP client & networking
reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
hyper = { version = "1.4", features = ["full"] }

# Async & Concurrency
futures = "0.3"
async-trait = "0.1"

# Logging & Tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
tracing-opentelemetry = "0.25"

# Configuration & Environment
config = "0.14"
dotenvy = "0.15"

# Time & UUID
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.10", features = ["v4", "v7", "serde"] }

# Validation & Parsing
validator = { version = "0.18", features = ["derive"] }
url = "2.5"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Security & Rate limiting
tower-governor = "0.4"
headers = "0.4"

# Blockchain integration
ethers = "2.0"
near-sdk = "5.4"
near-jsonrpc-client = "0.12"

# Monitoring & Metrics
metrics = "0.23"
metrics-exporter-prometheus = "0.15"

# API Documentation
utoipa = "5.0.1"
utoipa-swagger-ui = "8.0.2"
utoipa-axum = "0.1.0"

# Development & Testing
rstest = "0.23"
mockall = "0.13"
wiremock = "0.6"

# KEMBridge internal crates
kembridge-auth = { path = "crates/kembridge-auth" }
kembridge-crypto = { path = "crates/kembridge-crypto" }
kembridge-bridge = { path = "crates/kembridge-bridge" }
kembridge-database = { path = "crates/kembridge-database" }
kembridge-blockchain = { path = "crates/kembridge-blockchain" }

# Main gateway binary
[package]
name = "kembridge-backend"
version = "0.1.0"
edition = "2021"
rust-version = "1.88"

[dependencies]
# Core framework
axum.workspace = true
tokio.workspace = true
tower.workspace = true
tower-http.workspace = true

# State management
sqlx.workspace = true
redis.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Configuration
dotenvy.workspace = true
config.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Error handling
anyhow.workspace = true
thiserror.workspace = true

# Validation
validator.workspace = true

# Time & UUID
chrono.workspace = true
uuid.workspace = true

# Security
tower-governor.workspace = true
headers.workspace = true

# Monitoring
metrics.workspace = true
metrics-exporter-prometheus.workspace = true

# Internal crates
kembridge-auth.workspace = true
kembridge-database.workspace = true
kembridge-crypto.workspace = true
kembridge-bridge.workspace = true
kembridge-blockchain.workspace = true

[features]
default = ["production"]
development = ["tracing-subscriber/env-filter"]
production = ["tower-http/compression-gzip"]
testing = ["mockall", "wiremock"]
```

## üîß –î–µ—Ç–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤

### 1.3.1 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Axum –ø—Ä–æ–µ–∫—Ç–∞ —Å —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π

#### Main Application Setup

```rust
// src/main.rs - Modern Rust 1.88+ setup
use axum::{
    http::{Method, StatusCode},
    middleware,
    response::Json,
    routing::{get, post},
    Router,
};
use std::net::SocketAddr;
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer,
    cors::{Any, CorsLayer},
    limit::RequestBodyLimitLayer,
    trace::TraceLayer,
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod config;
mod routes;
mod middleware;
mod handlers;
mod extractors;
mod models;
mod services;
mod utils;

use config::AppConfig;
use middleware::{auth::auth_middleware, error_handler::handle_error};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize comprehensive tracing
    init_tracing()?;

    // Load configuration from environment
    let config = AppConfig::from_env()?;

    // Initialize database connections
    let db_pool = kembridge_database::create_pool(&config.database_url).await?;
    kembridge_database::run_migrations(&db_pool).await?;

    // Initialize Redis connection manager
    let redis_manager = redis::ConnectionManager::new(
        redis::Client::open(config.redis_url.as_str())?
    ).await?;

    // Create application state
    let app_state = AppState::new(db_pool, redis_manager, config.clone()).await?;

    // Build application with comprehensive middleware stack
    let app = create_application(app_state).await?;

    // Start server with graceful shutdown
    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    tracing::info!("üöÄ KEMBridge API Gateway starting on {}", addr);
    tracing::info!("üìã Health check available at http://{}/health", addr);
    tracing::info!("üìñ API documentation at http://{}/docs", addr);

    // Graceful shutdown handling
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn create_application(state: AppState) -> anyhow::Result<Router> {
    let app = Router::new()
        // Health & Status endpoints
        .route("/health", get(handlers::health::health_check))
        .route("/ready", get(handlers::health::readiness_check))
        .route("/metrics", get(handlers::health::metrics))

        // API v1 routes
        .nest("/api/v1", create_v1_routes())

        // WebSocket for real-time updates
        .route("/ws", get(handlers::websocket::websocket_handler))

        // Global middleware stack (applied in reverse order)
        .layer(
            ServiceBuilder::new()
                // Outermost: Error handling
                .layer(middleware::from_fn(handle_error))

                // Security & CORS
                .layer(create_cors_layer()?)

                // Request processing
                .layer(RequestBodyLimitLayer::new(1024 * 1024)) // 1MB limit
                .layer(CompressionLayer::new())

                // Observability
                .layer(
                    TraceLayer::new_for_http()
                        .make_span_with(middleware::trace::make_span)
                        .on_request(middleware::trace::on_request)
                        .on_response(middleware::trace::on_response)
                )

                // Rate limiting (applied per route)
                .layer(middleware::from_fn(middleware::rate_limit::rate_limit))
        )

        // Attach application state
        .with_state(state);

    Ok(app)
}

fn create_v1_routes() -> Router<AppState> {
    Router::new()
        // Authentication routes
        .nest("/auth", routes::auth::create_routes())

        // Bridge operation routes
        .nest("/bridge", routes::bridge::create_routes())

        // Quantum cryptography routes
        .nest("/quantum", routes::quantum::create_routes())

        // User management routes
        .nest("/user", routes::user::create_routes())

        // Admin routes (protected)
        .nest("/admin", routes::admin::create_routes())

        // Authentication middleware for protected routes
        .layer(middleware::from_fn_with_state(
            (), // State for middleware
            auth_middleware
        ))
}

fn create_cors_layer() -> anyhow::Result<CorsLayer> {
    let cors = CorsLayer::new()
        .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE, Method::OPTIONS])
        .allow_headers([
            "content-type",
            "authorization",
            "x-quantum-signature",
            "x-wallet-address",
            "x-request-id"
        ])
        .allow_origin(Any) // Configure based on environment
        .allow_credentials(true);

    Ok(cors)
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            tracing::info!("üõë Ctrl+C received, shutting down gracefully...");
        },
        _ = terminate => {
            tracing::info!("üõë SIGTERM received, shutting down gracefully...");
        },
    }
}

fn init_tracing() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "kembridge_backend=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer().json())
        .init();

    Ok(())
}
```

#### Advanced Application State Management

```rust
// Application state with dependency injection
#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
    pub redis: redis::ConnectionManager,
    pub config: AppConfig,
    pub auth_service: Arc<services::AuthService>,
    pub bridge_service: Arc<services::BridgeService>,
    pub quantum_service: Arc<services::QuantumService>,
    pub ai_client: Arc<services::AiClient>,
    pub metrics: Arc<metrics::Registry>,
}

impl AppState {
    pub async fn new(
        db: sqlx::PgPool,
        redis: redis::ConnectionManager,
        config: AppConfig,
    ) -> anyhow::Result<Self> {
        // Initialize services with dependency injection
        let auth_service = Arc::new(
            services::AuthService::new(db.clone(), redis.clone(), &config).await?
        );

        let quantum_service = Arc::new(
            services::QuantumService::new(db.clone(), &config).await?
        );

        let bridge_service = Arc::new(
            services::BridgeService::new(
                db.clone(),
                quantum_service.clone(),
                &config
            ).await?
        );

        let ai_client = Arc::new(
            services::AiClient::new(&config.ai_engine_url)?
        );

        let metrics = Arc::new(metrics::Registry::new());

        Ok(Self {
            db,
            redis,
            config,
            auth_service,
            bridge_service,
            quantum_service,
            ai_client,
            metrics,
        })
    }
}
```

### 1.3.2 Advanced CORS Configuration

```rust
// src/middleware/cors.rs - Production-ready CORS setup
use axum::http::{HeaderValue, Method};
use tower_http::cors::{CorsLayer, AllowOrigin};
use crate::config::AppConfig;

pub fn create_production_cors(config: &AppConfig) -> CorsLayer {
    let allowed_origins: Vec<HeaderValue> = config
        .cors_origins
        .iter()
        .filter_map(|origin| origin.parse().ok())
        .collect();

    CorsLayer::new()
        .allow_origin(AllowOrigin::list(allowed_origins))
        .allow_methods([
            Method::GET,
            Method::POST,
            Method::PUT,
            Method::DELETE,
            Method::PATCH,
            Method::OPTIONS,
        ])
        .allow_headers([
            "content-type",
            "authorization",
            "x-quantum-signature",
            "x-wallet-address",
            "x-request-id",
            "x-user-agent",
            "x-forwarded-for",
        ])
        .allow_credentials(true)
        .max_age(std::time::Duration::from_secs(3600))
}

pub fn create_development_cors() -> CorsLayer {
    CorsLayer::permissive()
}
```

### 1.3.3 PostgreSQL Integration —á–µ—Ä–µ–∑ SQLx

```rust
// src/services/database.rs - Advanced PostgreSQL 18 integration
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub struct DatabaseService {
    pool: PgPool,
}

impl DatabaseService {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    // PostgreSQL 18 UUIDv7 integration
    pub async fn generate_uuidv7(&self) -> sqlx::Result<Uuid> {
        let row = sqlx::query("SELECT generate_uuidv7() as id")
            .fetch_one(&self.pool)
            .await?;

        Ok(row.get("id"))
    }

    // Advanced transaction with quantum key integration
    pub async fn create_bridge_transaction(
        &self,
        user_id: Uuid,
        source_chain: &str,
        dest_chain: &str,
        amount: rust_decimal::Decimal,
        quantum_key_id: Option<Uuid>,
    ) -> sqlx::Result<Uuid> {
        let mut tx = self.pool.begin().await?;

        // Use PostgreSQL 18 function
        let transaction_id = sqlx::query_scalar!(
            r#"
            SELECT create_bridge_transaction(
                $1, $2, $3, 'ETH', 'NEAR', $4, NULL, $5, 24, NULL
            ) as "transaction_id!"
            "#,
            user_id,
            source_chain,
            dest_chain,
            amount,
            quantum_key_id
        )
        .fetch_one(&mut *tx)
        .await?;

        tx.commit().await?;
        Ok(transaction_id)
    }

    // Efficient JSON queries with PostgreSQL 18 SIMD optimization
    pub async fn get_user_risk_profile(&self, user_id: Uuid) -> sqlx::Result<serde_json::Value> {
        let risk_profile = sqlx::query_scalar!(
            r#"
            SELECT risk_profile
            FROM users
            WHERE id = $1 AND is_active = true
            "#,
            user_id
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(risk_profile.unwrap_or_else(|| serde_json::json!({"score": 0.0})))
    }
}
```

### 1.3.4 Redis Integration –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è

```rust
// src/services/cache.rs - Advanced Redis integration
use redis::{aio::ConnectionManager, AsyncCommands, RedisResult};
use serde::{Deserialize, Serialize};
use std::time::Duration;

#[derive(Debug, Clone)]
pub struct CacheService {
    manager: ConnectionManager,
}

impl CacheService {
    pub fn new(manager: ConnectionManager) -> Self {
        Self { manager }
    }

    // Generic cache operations with serialization
    pub async fn set_json<T>(&self, key: &str, value: &T, ttl: Duration) -> RedisResult<()>
    where
        T: Serialize,
    {
        let mut conn = self.manager.clone();
        let serialized = serde_json::to_string(value)
            .map_err(|e| redis::RedisError::from((redis::ErrorKind::TypeError, "Serialization failed", e.to_string())))?;

        conn.set_ex(key, serialized, ttl.as_secs()).await
    }

    pub async fn get_json<T>(&self, key: &str) -> RedisResult<Option<T>>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut conn = self.manager.clone();
        let value: Option<String> = conn.get(key).await?;

        match value {
            Some(serialized) => {
                let deserialized = serde_json::from_str(&serialized)
                    .map_err(|e| redis::RedisError::from((redis::ErrorKind::TypeError, "Deserialization failed", e.to_string())))?;
                Ok(Some(deserialized))
            },
            None => Ok(None),
        }
    }

    // Session management
    pub async fn store_session(&self, session_id: &str, user_id: Uuid, ttl: Duration) -> RedisResult<()> {
        let mut conn = self.manager.clone();
        let session_data = serde_json::json!({
            "user_id": user_id,
            "created_at": chrono::Utc::now(),
        });

        conn.set_ex(
            format!("session:{}", session_id),
            session_data.to_string(),
            ttl.as_secs()
        ).await
    }

    // Rate limiting with sliding window
    pub async fn check_rate_limit(&self, key: &str, limit: u32, window: Duration) -> RedisResult<bool> {
        let mut conn = self.manager.clone();
        let now = chrono::Utc::now().timestamp();
        let window_start = now - window.as_secs() as i64;

        // Remove expired entries
        let _: () = conn.zremrangebyscore(key, 0, window_start).await?;

        // Count current requests
        let count: u32 = conn.zcard(key).await?;

        if count >= limit {
            return Ok(false);
        }

        // Add current request
        let _: () = conn.zadd(key, now, format!("req:{}", uuid::Uuid::new_v4())).await?;
        let _: () = conn.expire(key, window.as_secs()).await?;

        Ok(true)
    }
}
```

### 1.3.5 Advanced Route Handlers

```rust
// src/handlers/health.rs - Comprehensive health checks
use axum::{extract::State, response::Json, http::StatusCode};
use serde_json::{json, Value};

pub async fn health_check(State(state): State<AppState>) -> Result<Json<Value>, StatusCode> {
    Ok(Json(json!({
        "status": "healthy",
        "service": "kembridge-api-gateway",
        "version": env!("CARGO_PKG_VERSION"),
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "rust_version": env!("RUSTC_VERSION"),
        "features": {
            "quantum_crypto": true,
            "ai_risk_engine": true,
            "cross_chain_bridge": true,
            "web3_auth": true
        }
    })))
}

pub async fn readiness_check(State(state): State<AppState>) -> Result<Json<Value>, StatusCode> {
    // Check database connectivity
    let db_status = match sqlx::query("SELECT 1").fetch_one(&state.db).await {
        Ok(_) => "healthy",
        Err(_) => "unhealthy",
    };

    // Check Redis connectivity
    let redis_status = match state.redis.clone().get::<_, Option<String>>("health_check").await {
        Ok(_) => "healthy",
        Err(_) => "unhealthy",
    };

    let overall_status = if db_status == "healthy" && redis_status == "healthy" {
        "ready"
    } else {
        "not_ready"
    };

    let status_code = if overall_status == "ready" {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };

    Ok(Json(json!({
        "status": overall_status,
        "components": {
            "database": {
                "status": db_status,
                "type": "postgresql-18"
            },
            "cache": {
                "status": redis_status,
                "type": "redis"
            },
            "quantum_crypto": {
                "status": "healthy",
                "algorithm": "ml-kem-1024"
            }
        },
        "timestamp": chrono::Utc::now().to_rfc3339()
    })))
}

pub async fn metrics(State(state): State<AppState>) -> Result<String, StatusCode> {
    // Export Prometheus metrics
    use metrics_exporter_prometheus::PrometheusHandle;

    let handle = metrics_exporter_prometheus::PrometheusBuilder::new()
        .build_recorder()
        .handle();

    Ok(handle.render())
}
```

### 1.3.6 Advanced Tracing & Logging

```rust
// src/middleware/trace.rs - Comprehensive observability
use axum::http::{Request, Response};
use tracing::{info_span, Span};
use uuid::Uuid;

pub fn make_span<B>(request: &Request<B>) -> Span {
    let request_id = Uuid::new_v4();

    info_span!(
        "http_request",
        method = %request.method(),
        uri = %request.uri(),
        version = ?request.version(),
        request_id = %request_id,
        user_agent = request.headers()
            .get("user-agent")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown"),
        quantum_signature = request.headers()
            .contains_key("x-quantum-signature"),
        wallet_address = request.headers()
            .get("x-wallet-address")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("anonymous"),
    )
}

pub fn on_request<B>(request: &Request<B>, _span: &Span) {
    tracing::info!("üîÑ Processing request");
}

pub fn on_response<B>(response: &Response<B>, latency: std::time::Duration, _span: &Span) {
    tracing::info!(
        "‚úÖ Request completed",
        status = %response.status(),
        latency_ms = latency.as_millis(),
    );
}
```

### 1.3.7 Advanced Error Handling

```rust
// src/middleware/error_handler.rs - Comprehensive error handling
use axum::{
    http::StatusCode,
    response::{Json, Response},
    middleware::Next,
    extract::Request,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ApiError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("Redis error: {0}")]
    Redis(#[from] redis::RedisError),

    #[error("Authentication failed: {0}")]
    Authentication(String),

    #[error("Quantum signature verification failed")]
    QuantumSignature,

    #[error("Bridge operation failed: {0}")]
    Bridge(String),

    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Internal server error")]
    Internal,
}

impl From<ApiError> for Response {
    fn from(error: ApiError) -> Self {
        let (status, code, message) = match error {
            ApiError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "DATABASE_ERROR", "Database operation failed"),
            ApiError::Redis(_) => (StatusCode::INTERNAL_SERVER_ERROR, "CACHE_ERROR", "Cache operation failed"),
            ApiError::Authentication(msg) => (StatusCode::UNAUTHORIZED, "AUTH_FAILED", &msg),
            ApiError::QuantumSignature => (StatusCode::UNAUTHORIZED, "QUANTUM_SIGNATURE_INVALID", "Quantum signature verification failed"),
            ApiError::Bridge(msg) => (StatusCode::BAD_REQUEST, "BRIDGE_ERROR", &msg),
            ApiError::RateLimit => (StatusCode::TOO_MANY_REQUESTS, "RATE_LIMIT_EXCEEDED", "Too many requests"),
            ApiError::Validation(msg) => (StatusCode::BAD_REQUEST, "VALIDATION_ERROR", &msg),
            ApiError::Internal => (StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR", "Internal server error"),
        };

        let body = Json(json!({
            "error": {
                "code": code,
                "message": message,
                "timestamp": chrono::Utc::now().to_rfc3339(),
            }
        }));

        (status, body).into_response()
    }
}

pub async fn handle_error(request: Request, next: Next) -> Response {
    let response = next.run(request).await;

    // Add error correlation ID for tracking
    if response.status().is_client_error() || response.status().is_server_error() {
        tracing::error!(
            "‚ùå Request failed with status: {}",
            response.status()
        );
    }

    response
}
```

### 1.3.8 Modern Data Structures with OpenAPI Documentation

```rust
// src/models/mod.rs - Type-safe request/response models with OpenAPI generation
use serde::{Deserialize, Serialize};
use validator::Validate;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use utoipa::{ToSchema, OpenApi};
use utoipa_swagger_ui::{SwaggerUi, Url};

#[derive(Debug, Serialize, Deserialize, Validate, ToSchema)]
pub struct BridgeSwapRequest {
    #[validate(length(min = 1, max = 20))]
    pub source_chain: String,

    #[validate(length(min = 1, max = 20))]
    pub destination_chain: String,

    #[validate(length(min = 1, max = 10))]
    pub source_token: String,

    #[validate(length(min = 1, max = 10))]
    pub destination_token: String,

    #[validate(range(min = 0.000001))]
    pub amount: f64,

    pub quantum_key_id: Option<Uuid>,

    #[validate(range(min = 1, max = 168))] // 1 hour to 1 week
    pub expires_in_hours: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct BridgeSwapResponse {
    pub transaction_id: Uuid,
    pub status: TransactionStatus,
    pub estimated_completion: DateTime<Utc>,
    pub bridge_fee: f64,
    pub network_fee: f64,
    pub quantum_protection_fee: f64,
    pub exchange_rate: f64,
    pub expected_output: f64,
    pub risk_score: f64,
    pub quantum_protected: bool,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TransactionStatus {
    Pending,
    Validating,
    Locked,
    Processing,
    Confirming,
    Confirmed,
    Completed,
    Failed,
    Cancelled,
    Expired,
    Refunded,
}

#[derive(Debug, Serialize, Deserialize, Validate, ToSchema)]
pub struct AuthRequest {
    #[validate(length(min = 42, max = 42))] // Ethereum address length
    pub wallet_address: String,

    #[validate(length(min = 1))]
    pub signature: String,

    #[validate(length(min = 1))]
    pub message: String,

    #[validate(length(min = 1, max = 20))]
    pub chain_type: String,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct AuthResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    pub expires_in: u64,
    pub user_id: Uuid,
    pub wallet_address: String,
    pub quantum_keys_available: bool,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct QuantumKeyPair {
    pub key_id: Uuid,
    pub public_key: String,
    pub algorithm: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub key_strength: String,
    pub usage_category: String,
}
```

## üìä Performance & Security Considerations

### High-Performance Configuration

```rust
// Performance optimizations for production
[profile.release]
lto = true              # Link-time optimization
codegen-units = 1       # Single codegen unit for better optimization
panic = "abort"         # Smaller binary size
strip = true           # Strip symbols

[profile.release.package.kembridge-crypto]
opt-level = 3          # Maximum optimization for crypto operations
```

### Security Headers & Middleware

```rust
// Security middleware stack
use tower_http::set_header::SetResponseHeaderLayer;
use axum::http::header;

pub fn security_headers() -> SetResponseHeaderLayer<HeaderValue> {
    ServiceBuilder::new()
        .layer(SetResponseHeaderLayer::overriding(
            header::X_CONTENT_TYPE_OPTIONS,
            HeaderValue::from_static("nosniff"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::X_FRAME_OPTIONS,
            HeaderValue::from_static("DENY"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::X_XSS_PROTECTION,
            HeaderValue::from_static("1; mode=block"),
        ))
        .layer(SetResponseHeaderLayer::overriding(
            header::STRICT_TRANSPORT_SECURITY,
            HeaderValue::from_static("max-age=31536000; includeSubDomains"),
        ))
}
```

## üéØ –ß–µ–∫–ø–æ–∏–Ω—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ 1.3

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö 8 –ø–æ–¥–ø—É–Ω–∫—Ç–æ–≤ —Å–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞:

### ‚úÖ –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π API Gateway

- **Axum 0.8+ backend** —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ Docker –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
- **PostgreSQL 18** –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ SQLx —Å UUIDv7 –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π
- **Redis** –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Å–µ—Å—Å–∏–π
- **Comprehensive middleware** stack —Å CORS, rate limiting, tracing
- **Type-safe extractors** –¥–ª—è –≤—Å–µ—Ö request/response –¥–∞–Ω–Ω—ã—Ö
- **Advanced error handling** —Å structured logging
- **Health checks** –¥–ª—è monitoring –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å–∞
- **WebSocket support** –¥–ª—è real-time —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π

### üîó API Endpoints Ready

```bash
# Health checks
GET  /health          # Service health
GET  /ready           # Readiness probe
GET  /metrics         # Prometheus metrics

# Authentication (Phase 2.1)
POST /api/v1/auth/nonce      # Generate nonce for signing
POST /api/v1/auth/verify     # Verify Web3 signature
POST /api/v1/auth/refresh    # Refresh JWT token

# Bridge operations (Phase 4.3)
POST /api/v1/bridge/swap     # Initiate cross-chain swap
GET  /api/v1/bridge/status/{id} # Get transaction status
GET  /api/v1/bridge/quote    # Get swap quote

# Quantum crypto (Phase 3.2)
POST /api/v1/quantum/generate # Generate quantum key pair
POST /api/v1/quantum/encrypt  # Encrypt data
POST /api/v1/quantum/decrypt  # Decrypt data

# WebSocket
WS   /ws              # Real-time updates
```

### üöÄ Ready for Phase 2: Authentication & Authorization

Solid foundation –≥–æ—Ç–æ–≤ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏:

- Web3 signature verification (Phase 2.1)
- JWT session management (Phase 2.2)
- Quantum cryptography integration (Phase 3.1)
- Cross-chain bridge logic (Phase 4.1)

**–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é ready:**

- Rust 1.88+ —Å async/await improvements
- Axum 0.8+ —Å production-grade middleware
- PostgreSQL 18 —Å UUIDv7 –∏ JSONB optimization
- Redis –¥–ª—è high-performance caching
- OpenAPI/Swagger UI –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
- Comprehensive observability —Å OpenTelemetry

–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —ç—Ç–∞–ø—É - **Phase 2.1: Web3 Authentication Service**!

## üìñ OpenAPI/Swagger Documentation Integration

### Comprehensive API Documentation with utoipa

```rust
// src/openapi.rs - OpenAPI schema definition
use utoipa::{OpenApi, Modify};
use crate::models::*;

#[derive(OpenApi)]
#[openapi(
    paths(
        crate::handlers::health::health_check,
        crate::handlers::health::readiness_check,
        crate::handlers::auth::generate_nonce,
        crate::handlers::auth::verify_signature,
        crate::handlers::bridge::initiate_swap,
        crate::handlers::bridge::get_swap_status,
        crate::handlers::quantum::generate_keypair,
    ),
    components(
        schemas(
            BridgeSwapRequest,
            BridgeSwapResponse,
            TransactionStatus,
            AuthRequest,
            AuthResponse,
            QuantumKeyPair,
            ErrorResponse,
            HealthStatus,
        )
    ),
    modifiers(&SecurityAddon),
    tags(
        (name = "Health", description = "Health check endpoints"),
        (name = "Authentication", description = "Web3 wallet authentication"),
        (name = "Bridge", description = "Cross-chain bridge operations"),
        (name = "Quantum", description = "Post-quantum cryptography operations"),
    ),
    info(
        title = "KEMBridge API",
        version = "1.0.0",
        description = "Quantum-secure cross-chain bridge API",
        contact(
            name = "KEMBridge Team",
            email = "support@kembridge.io",
        ),
        license(
            name = "MIT",
            url = "https://opensource.org/licenses/MIT",
        ),
    ),
    servers(
        (url = "http://localhost:3000", description = "Development server"),
        (url = "https://api.kembridge.io", description = "Production server"),
    ),
)]
pub struct ApiDoc;

struct SecurityAddon;

impl Modify for SecurityAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        use utoipa::openapi::security::*;
        
        let mut security_schemes = utoipa::openapi::security::SecuritySchemes::new();
        security_schemes.insert(
            "bearerAuth",
            SecurityScheme::Http(Http::new(HttpAuthScheme::Bearer))
        );
        
        openapi.components = Some(
            utoipa::openapi::ComponentsBuilder::new()
                .security_schemes(security_schemes)
                .build()
        );
    }
}
```

### Handler Documentation Examples

```rust
// src/handlers/bridge.rs - Documented API handlers
use axum::{extract::State, Json, response::Json as ResponseJson};
use utoipa::path;
use crate::{AppState, models::*};

/// Initiate cross-chain swap
#[utoipa::path(
    post,
    path = "/api/v1/bridge/swap",
    request_body = BridgeSwapRequest,
    responses(
        (status = 200, description = "Swap initiated successfully", body = BridgeSwapResponse),
        (status = 400, description = "Invalid request parameters", body = ErrorResponse),
        (status = 401, description = "Authentication required", body = ErrorResponse),
        (status = 402, description = "Insufficient balance", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
    ),
    security(
        ("bearerAuth" = [])
    ),
    tag = "Bridge"
)]
pub async fn initiate_swap(
    State(state): State<AppState>,
    Json(request): Json<BridgeSwapRequest>,
) -> Result<ResponseJson<BridgeSwapResponse>, AppError> {
    // Implementation here...
    todo!()
}

/// Get swap transaction status
#[utoipa::path(
    get,
    path = "/api/v1/bridge/status/{transaction_id}",
    params(
        ("transaction_id" = String, Path, description = "Transaction UUID")
    ),
    responses(
        (status = 200, description = "Transaction status retrieved", body = BridgeSwapResponse),
        (status = 404, description = "Transaction not found", body = ErrorResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
    ),
    security(
        ("bearerAuth" = [])
    ),
    tag = "Bridge"
)]
pub async fn get_swap_status(
    State(state): State<AppState>,
    Path(transaction_id): Path<String>,
) -> Result<ResponseJson<BridgeSwapResponse>, AppError> {
    // Implementation here...
    todo!()
}
```

### Interactive Swagger UI Integration

```rust
// src/main.rs - Updated with Swagger UI
use utoipa_swagger_ui::SwaggerUi;
use crate::openapi::ApiDoc;

pub fn create_router(state: AppState) -> Router {
    let api_routes = Router::new()
        .route("/health", get(handlers::health::health_check))
        .route("/ready", get(handlers::health::readiness_check))
        .nest("/api/v1", api_v1_routes())
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(CorsLayer::permissive())
                .layer(RequestBodyLimitLayer::new(1024 * 1024))
                .layer(CompressionLayer::new())
                .layer(RateLimitLayer::new(100, Duration::from_secs(60)))
                .layer(AuthLayer::new(quantum_auth_handler))
        );

    Router::new()
        .merge(api_routes)
        // Swagger UI integration
        .merge(
            SwaggerUi::new("/docs")
                .url("/openapi.json", ApiDoc::openapi())
                .config(
                    utoipa_swagger_ui::Config::new(["/openapi.json"])
                        .try_it_out_enabled(true)
                        .filter(true)
                        .show_extensions(true)
                )
        )
        // Raw OpenAPI JSON for API clients
        .route(
            "/openapi.json",
            get(|| async { Json(ApiDoc::openapi()) })
        )
        .with_state(state)
}
```

### Error Response Schema

```rust
// src/models/error.rs - Structured error responses
#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub details: Option<serde_json::Value>,
    pub timestamp: DateTime<Utc>,
    pub request_id: String,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ValidationError {
    pub field: String,
    pub message: String,
    pub value: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct HealthStatus {
    pub status: String,
    pub version: String,
    pub timestamp: DateTime<Utc>,
    pub services: HashMap<String, ServiceHealth>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ServiceHealth {
    pub status: String,
    pub response_time_ms: u64,
    pub last_check: DateTime<Utc>,
}
```

### API Documentation Features

**üîç –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏:**
- ‚úÖ **Interactive Swagger UI** –ø–æ –∞–¥—Ä–µ—Å—É `/docs`
- ‚úÖ **OpenAPI 3.0 JSON** —Å—Ö–µ–º–∞ –ø–æ –∞–¥—Ä–µ—Å—É `/openapi.json`
- ‚úÖ **Type-safe request/response** –º–æ–¥–µ–ª–∏ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
- ‚úÖ **Authentication —Å—Ö–µ–º—ã** —Å JWT Bearer tokens
- ‚úÖ **Error handling** —Å –ø–æ–¥—Ä–æ–±–Ω—ã–º–∏ HTTP status codes
- ‚úÖ **Code generation support** –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫

**üìä Production-ready –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
- ‚úÖ **Multiple environments** (dev, staging, production)
- ‚úÖ **API versioning** –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- ‚úÖ **Security definitions** –¥–ª—è –≤—Å–µ—Ö protected endpoints
- ‚úÖ **Request/Response examples** –¥–ª—è –∫–∞–∂–¥–æ–≥–æ endpoint
- ‚úÖ **Parameter validation** —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º constraints

**üöÄ Developer Experience:**
- ‚úÖ **Try it out** —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ
- ‚úÖ **curl –∫–æ–º–∞–Ω–¥—ã** –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è
- ‚úÖ **SDK generation** –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —è–∑—ã–∫–æ–≤
- ‚úÖ **API testing** –ø—Ä—è–º–æ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
- ‚úÖ **Filtering –∏ search** –ø–æ endpoints
