# Phase 3.3: Hybrid Cryptography Guide

## üìã –û–±–∑–æ—Ä —Ñ–∞–∑—ã

**–¶–µ–ª—å:** –°–æ–∑–¥–∞–Ω–∏–µ –≥–∏–±—Ä–∏–¥–Ω–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–π —Å–∏—Å—Ç–µ–º—ã ML-KEM-1024 + AES-256-GCM –¥–ª—è –∑–∞—â–∏—Ç—ã —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** Phase 3.2 (Quantum Key Management), Phase 3.1 (ML-KEM-1024 Implementation)
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ü–æ–ª–Ω–∞—è –≥–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤ bridge workflow

## üéØ –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **–ì–∏–±—Ä–∏–¥–Ω–æ—Å—Ç—å:** –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –ø–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤–æ–π (ML-KEM) –∏ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–π (AES-GCM) –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
2. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:** –ó–∞—â–∏—Ç–∞ –æ—Ç –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏—Ö –∏ –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –∞—Ç–∞–∫ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
3. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ AES –¥–ª—è bulk data, ML-KEM –¥–ª—è key establishment
4. **–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:** –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π QuantumService –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π

## üìö –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã

### –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å—Ö–µ–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   ML-KEM-1024   ‚îÇ    ‚îÇ   AES-256-GCM    ‚îÇ    ‚îÇ  Transaction    ‚îÇ
‚îÇ (Key Exchange)  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ (Data Encryption)‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ     Data        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº
  Shared Secret (32B)    ‚îÄ‚îÄ‚ñ∂  AES Key + IV
```

### –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã

- **ML-KEM-1024:** FIPS 203 –¥–ª—è post-quantum key establishment
- **AES-256-GCM:** FIPS 197 + SP 800-38D –¥–ª—è authenticated encryption
- **KDF:** HKDF-SHA256 (RFC 5869) –¥–ª—è –∫–ª—é—á–µ–≤–æ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
- **Nonce:** Secure random generation –¥–ª—è –∫–∞–∂–¥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è

### –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ kembridge-crypto crate

```
backend/crates/kembridge-crypto/src/
‚îú‚îÄ‚îÄ lib.rs                     # Updated exports –¥–ª—è hybrid —Å—Ö–µ–º—ã
‚îú‚îÄ‚îÄ ml_kem.rs                  # Existing ML-KEM-1024 (Phase 3.1)
‚îú‚îÄ‚îÄ hybrid_crypto.rs           # NEW: Hybrid encryption implementation
‚îú‚îÄ‚îÄ aes_gcm.rs                # NEW: AES-256-GCM wrapper
‚îú‚îÄ‚îÄ kdf.rs                    # NEW: Key derivation functions
‚îú‚îÄ‚îÄ data_protection.rs        # NEW: Transaction data encryption
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ hybrid_tests.rs       # NEW: Hybrid —Å—Ö–µ–º–∞ —Ç–µ—Å—Ç—ã
    ‚îî‚îÄ‚îÄ data_encryption_tests.rs # NEW: End-to-end data protection
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ backend —Å–µ—Ä–≤–∏—Å—ã

```
backend/src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ quantum.rs            # Existing QuantumService (Phase 3.2)
‚îÇ   ‚îî‚îÄ‚îÄ data_protection.rs    # NEW: DataProtectionService
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îî‚îÄ‚îÄ crypto.rs             # Updated –¥–ª—è hybrid endpoints
‚îî‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ quantum.rs            # Existing (Phase 3.2)
    ‚îî‚îÄ‚îÄ encrypted_data.rs     # NEW: –ú–æ–¥–µ–ª–∏ –¥–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
```

## üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### 3.3.1 –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏ (AES-256-GCM)

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç –≥–∏–±—Ä–∏–¥–Ω–æ–π —Å—Ö–µ–º—ã

```rust
// kembridge-crypto/src/aes_gcm.rs
use aes_gcm::{Aes256Gcm, Key, Nonce, Aead, KeyInit};
use rand::{Rng, thread_rng};

pub struct AesGcmCrypto;

impl AesGcmCrypto {
    /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ AES-256 –∫–ª—é—á–∞
    pub fn generate_key() -> [u8; 32] {
        let mut key = [0u8; 32];
        thread_rng().fill(&mut key);
        key
    }

    /// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å AES-256-GCM
    pub fn encrypt(
        key: &[u8; 32], 
        data: &[u8]
    ) -> Result<EncryptedData, CryptoError> {
        let cipher = Aes256Gcm::new(Key::from_slice(key));
        let nonce = Self::generate_nonce();
        
        let ciphertext = cipher.encrypt(&nonce, data)
            .map_err(|e| CryptoError::EncryptionFailed(e.to_string()))?;
            
        Ok(EncryptedData {
            ciphertext,
            nonce: nonce.to_vec(),
        })
    }
}
```

**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:**
```toml
# Cargo.toml additions
aes-gcm = "0.10.3"          # AES-256-GCM implementation
hkdf = "0.12.4"             # HKDF key derivation
```

### 3.3.2 –°–æ–∑–¥–∞–Ω–∏–µ –≥–∏–±—Ä–∏–¥–Ω–æ–π —Å—Ö–µ–º—ã (ML-KEM + AES)

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - –æ—Å–Ω–æ–≤–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

```rust
// kembridge-crypto/src/hybrid_crypto.rs
use crate::{MlKemCrypto, AesGcmCrypto, QuantumCryptoError};
use crate::kdf::derive_encryption_key;

pub struct HybridCrypto;

impl HybridCrypto {
    /// –ì–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ: ML-KEM –¥–ª—è –∫–ª—é—á–∞, AES –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
    pub async fn encrypt_data(
        public_key_id: Uuid,
        data: &[u8],
        quantum_service: &QuantumService
    ) -> Result<HybridEncryptedData, QuantumCryptoError> {
        // 1. –ü–æ–ª—É—á–µ–Ω–∏–µ ML-KEM –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞
        let quantum_key = quantum_service.get_public_key(public_key_id).await?;
        let encapsulation_key = MlKemCrypto::import_public_key(&quantum_key.public_key)?;
        
        // 2. ML-KEM encapsulation –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è shared secret
        let (ciphertext, shared_secret) = MlKemCrypto::encapsulate(&encapsulation_key)?;
        
        // 3. –ö–ª—é—á–µ–≤–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ shared secret ‚Üí AES key
        let aes_key = derive_encryption_key(&shared_secret)?;
        
        // 4. AES-256-GCM —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        let encrypted_data = AesGcmCrypto::encrypt(&aes_key, data)?;
        
        Ok(HybridEncryptedData {
            ml_kem_ciphertext: ciphertext,
            aes_encrypted_data: encrypted_data,
            public_key_id,
        })
    }
}
```

### 3.3.3 –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å bridge –¥–∞–Ω–Ω—ã–º–∏

```rust
// kembridge-crypto/src/data_protection.rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionData {
    pub from_chain: String,
    pub to_chain: String,
    pub asset: String,
    pub amount: String,
    pub recipient: String,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedTransactionData {
    pub encrypted_payload: HybridEncryptedData,
    pub transaction_hash: String,
    pub encryption_timestamp: DateTime<Utc>,
}

impl TransactionData {
    /// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è cross-chain transfer
    pub async fn encrypt_for_bridge(
        &self,
        user_quantum_key_id: Uuid,
        quantum_service: &QuantumService
    ) -> Result<EncryptedTransactionData, QuantumCryptoError> {
        let serialized = serde_json::to_vec(self)
            .map_err(|e| QuantumCryptoError::SerializationError(e.to_string()))?;
            
        let encrypted_payload = HybridCrypto::encrypt_data(
            user_quantum_key_id,
            &serialized,
            quantum_service
        ).await?;
        
        Ok(EncryptedTransactionData {
            encrypted_payload,
            transaction_hash: self.calculate_hash(),
            encryption_timestamp: Utc::now(),
        })
    }
}
```

### 3.3.4 –°–æ–∑–¥–∞–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - –ø—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è bridge –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏

```rust
// kembridge-crypto/src/key_exchange.rs
#[derive(Debug, Serialize, Deserialize)]
pub struct KeyExchangeRequest {
    pub public_key_id: Uuid,
    pub requesting_chain: String,
    pub session_metadata: serde_json::Value,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct KeyExchangeResponse {
    pub session_id: Uuid,
    pub ml_kem_ciphertext: Vec<u8>,  // Encrypted shared secret
    pub expires_at: DateTime<Utc>,
}

pub struct SecureKeyExchange;

impl SecureKeyExchange {
    /// –ò–Ω–∏—Ü–∏–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏ –º–µ–∂–¥—É —á–µ–π–Ω–∞–º–∏
    pub async fn initiate_exchange(
        request: KeyExchangeRequest,
        quantum_service: &QuantumService
    ) -> Result<KeyExchangeResponse, QuantumCryptoError> {
        // 1. –í–∞–ª–∏–¥–∞—Ü–∏—è quantum –∫–ª—é—á–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let quantum_key = quantum_service.get_public_key(request.public_key_id).await?;
        
        // 2. ML-KEM encapsulation –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è session secret
        let encapsulation_key = MlKemCrypto::import_public_key(&quantum_key.public_key)?;
        let (ciphertext, _shared_secret) = MlKemCrypto::encapsulate(&encapsulation_key)?;
        
        // 3. –°–æ–∑–¥–∞–Ω–∏–µ session –¥–ª—è bridge –æ–ø–µ—Ä–∞—Ü–∏–π
        let session_id = Uuid::new_v4();
        
        Ok(KeyExchangeResponse {
            session_id,
            ml_kem_ciphertext: ciphertext.as_bytes().to_vec(),
            expires_at: Utc::now() + Duration::hours(1),
        })
    }
}
```

### 3.3.5 –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è bridge –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

```rust
// kembridge-crypto/src/integrity.rs
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};

type HmacSha256 = Hmac<Sha256>;

pub struct IntegrityProtection;

impl IntegrityProtection {
    /// HMAC –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    pub fn generate_mac(
        key: &[u8],
        data: &[u8]
    ) -> Result<Vec<u8>, QuantumCryptoError> {
        let mut mac = HmacSha256::new_from_slice(key)
            .map_err(|e| QuantumCryptoError::MacError(e.to_string()))?;
        mac.update(data);
        Ok(mac.finalize().into_bytes().to_vec())
    }

    /// –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
    pub fn verify_integrity(
        key: &[u8],
        data: &[u8],
        expected_mac: &[u8]
    ) -> Result<bool, QuantumCryptoError> {
        let computed_mac = Self::generate_mac(key, data)?;
        Ok(computed_mac == expected_mac)
    }
}
```

### 3.3.6 –°–æ–∑–¥–∞–Ω–∏–µ —É—Ç–∏–ª–∏—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 3.3 - —É–¥–æ–±–Ω—ã–µ API –¥–ª—è backend

```rust
// backend/src/services/data_protection.rs
use kembridge_crypto::{HybridCrypto, EncryptedTransactionData};

pub struct DataProtectionService {
    quantum_service: Arc<QuantumService>,
}

impl DataProtectionService {
    pub fn new(quantum_service: Arc<QuantumService>) -> Self {
        Self { quantum_service }
    }

    /// –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ bridge –¥–∞–Ω–Ω—ã—Ö
    pub async fn protect_bridge_data(
        &self,
        user_id: Uuid,
        transaction_data: &TransactionData
    ) -> Result<ProtectedData, ServiceError> {
        // 1. –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ quantum –∫–ª—é—á–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let user_keys = self.quantum_service.list_user_keys(user_id).await?;
        let active_key = user_keys.keys.into_iter()
            .find(|k| k.is_active)
            .ok_or(ServiceError::NoActiveQuantumKey)?;

        // 2. –ì–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
        let encrypted = transaction_data
            .encrypt_for_bridge(active_key.id, &self.quantum_service)
            .await?;

        // 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î –¥–ª—è audit trail
        self.store_encrypted_data(&encrypted).await?;

        Ok(ProtectedData {
            data_id: Uuid::new_v4(),
            encrypted_payload: encrypted,
            protection_level: "hybrid_ml_kem_aes256".to_string(),
        })
    }
}
```

### 3.3.7 –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å PostgreSQL –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚è∏Ô∏è –ß–∞—Å—Ç–∏—á–Ω–æ –æ—Ç–ª–æ–∂–µ–Ω–æ –¥–æ Phase 4.3 - —Ç—Ä–µ–±—É–µ—Ç bridge integration

**–ü—Ä–∏—á–∏–Ω—ã —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –ø–µ—Ä–µ–Ω–æ—Å–∞:**
1. –ë–∞–∑–æ–≤–∞—è —Å—Ö–µ–º–∞ –ë–î —Å–æ–∑–¥–∞–µ—Ç—Å—è –≤ Phase 3.3
2. –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å bridge workflow –≤ Phase 4.3
3. –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç bridge service –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

```sql
-- –ë—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ Phase 3.3
CREATE TABLE encrypted_bridge_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) NOT NULL,
    quantum_key_id UUID REFERENCES quantum_keys(id) NOT NULL,
    
    -- –ì–∏–±—Ä–∏–¥–Ω—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    ml_kem_ciphertext BYTEA NOT NULL,
    aes_encrypted_payload BYTEA NOT NULL,
    aes_nonce BYTEA NOT NULL,
    
    -- –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    data_type VARCHAR(50) NOT NULL, -- 'bridge_transaction', 'key_exchange', etc
    encryption_algorithm VARCHAR(100) DEFAULT 'ml_kem_1024_aes_256_gcm',
    integrity_hash BYTEA NOT NULL,
    
    -- –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE,
    accessed_at TIMESTAMP WITH TIME ZONE,
    
    -- –ê—É–¥–∏—Ç
    bridge_session_id UUID,
    transaction_hash VARCHAR(66), -- Ethereum tx hash
    
    CONSTRAINT encrypted_data_valid_type CHECK (
        data_type IN ('bridge_transaction', 'key_exchange', 'metadata')
    )
);
```

## üîÑ –°–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ —Ñ–∞–∑–∞–º–∏

### –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ Phase 3.3

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚è∏Ô∏è –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ Phase 4.3 - —Ç—Ä–µ–±—É–µ—Ç bridge service –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è session –∫–ª—é—á–µ–π** ‚Üí Phase 4.3.5
- **Integration —Å Ethereum/NEAR adapters** ‚Üí Phase 4.3.6  
- **Performance optimizations –¥–ª—è bulk data** ‚Üí Phase 8.2.3
- **Advanced key derivation —Å—Ö–µ–º—ã** ‚Üí Phase 8.2.4

**–ü—Ä–∏—á–∏–Ω—ã –ø–µ—Ä–µ–Ω–æ—Å–∞:**

1. Phase 3.3 —Ñ–æ–∫—É—Å–∏—Ä—É–µ—Ç—Å—è –Ω–∞ core hybrid –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
2. Bridge-specific –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Ç—Ä–µ–±—É—é—Ç bridge service (Phase 4.3)
3. Performance optimizations –ª—É—á—à–µ –¥–µ–ª–∞—Ç—å –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞

### –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥—Ä—É–≥–∏—Ö —Ñ–∞–∑

- **Phase 3.1:** ML-KEM-1024 implementation ‚úÖ
- **Phase 3.2:** QuantumService –¥–ª—è key management ‚úÖ
- **Phase 4.3:** Bridge service –¥–ª—è –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
- **Phase 5.2:** AI risk analysis –¥–ª—è encrypted data patterns

## üìä –ö—Ä–∏—Ç–µ—Ä–∏–∏ —É—Å–ø–µ—Ö–∞ Phase 3.3

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:

- [ ] AES-256-GCM wrapper —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [ ] –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å—Ö–µ–º–∞ ML-KEM + AES —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞
- [ ] –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ/—Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- [ ] HKDF –∫–ª—é—á–µ–≤–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç
- [ ] –ü—Ä–æ—Ç–æ–∫–æ–ª –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏ —Å–æ–∑–¥–∞–Ω
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ HMAC-SHA256
- [ ] PostgreSQL —Å—Ö–µ–º–∞ –¥–ª—è encrypted data –≥–æ—Ç–æ–≤–∞

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:

- [ ] –ü–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤–∞—è + –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
- [ ] Authenticated encryption —Å GCM —Ä–µ–∂–∏–º–æ–º
- [ ] Secure key derivation —Å HKDF
- [ ] Memory safety –¥–ª—è –≤—Å–µ—Ö crypto –æ–ø–µ—Ä–∞—Ü–∏–π
- [ ] Audit trail –¥–ª—è –≤—Å–µ—Ö crypto –æ–ø–µ—Ä–∞—Ü–∏–π

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:

- [ ] Hybrid encryption < 5ms –¥–ª—è transaction data
- [ ] Key derivation < 1ms 
- [ ] Bulk data —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ (AES-NI)
- [ ] –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ª–∞—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –¥–ª—è bridge –æ–ø–µ—Ä–∞—Ü–∏–π

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è:

- [ ] Seamless –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å QuantumService
- [ ] HTTP endpoints –¥–ª—è hybrid operations
- [ ] OpenAPI –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞
- [ ] –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ bridge integration (Phase 4.3)

## ‚ö†Ô∏è –í–∞–∂–Ω—ã–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è

1. **–ì–∏–±—Ä–∏–¥–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:** –°—Ö–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–∞ –Ω–∞—Å—Ç–æ–ª—å–∫–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –±–µ–∑–æ–ø–∞—Å–µ–Ω —Å–∞–º—ã–π —Å–ª–∞–±—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
2. **Key Management:** –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏ –º–æ–∂–µ—Ç –∫–æ–º–ø—Ä–æ–º–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å—é —Å—Ö–µ–º—É
3. **Performance Trade-offs:** –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å—Ö–µ–º–∞ –º–µ–¥–ª–µ–Ω–Ω–µ–µ —á–∏—Å—Ç–æ–≥–æ AES, –Ω–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç PQ –∑–∞—â–∏—Ç—É
4. **Compatibility:** –ù—É–∂–Ω–æ –æ–±–µ—Å–ø–µ—á–∏—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –º–µ–∂–¥—É chain adapters

## üöÄ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Phase 3.3:

1. **Phase 4.1-4.2:** Blockchain Adapters - Ethereum –∏ NEAR –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
2. **Phase 4.3:** Bridge Service - –ø–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è hybrid crypto –≤ bridge workflow
3. **Phase 5.2:** AI Risk Integration - –∞–Ω–∞–ª–∏–∑ encrypted patterns –¥–ª—è threat detection
4. **Phase 8.2:** Performance Optimization - –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è crypto –æ–ø–µ—Ä–∞—Ü–∏–π

---

**–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç Phase 3.3:** –ü–æ–ª–Ω–∞—è –≥–∏–±—Ä–∏–¥–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ ML-KEM-1024 + AES-256-GCM –¥–ª—è –∑–∞—â–∏—Ç—ã cross-chain —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π, –≥–æ—Ç–æ–≤–∞—è –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤ bridge service.