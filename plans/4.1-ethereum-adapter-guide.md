# Phase 4.1: Ethereum Adapter Implementation Guide

## üìã –û–±–∑–æ—Ä —Ñ–∞–∑—ã

**–¶–µ–ª—å:** –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Ethereum –∞–¥–∞–ø—Ç–µ—Ä–∞ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å Sepolia testnet  
**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** Phase 3.4 (Quantum Crypto API) - –¥–ª—è –∑–∞—â–∏—Ç—ã —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π  
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞—é—â–∏–π Ethereum –∞–¥–∞–ø—Ç–µ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π ETH –∏ ERC-20 –æ–ø–µ—Ä–∞—Ü–∏–π

## üéØ –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **Testnet First:** –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å Sepolia testnet –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
2. **Quantum Protection:** –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Phase 3 –¥–ª—è –∑–∞—â–∏—Ç—ã –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–ª—é—á–µ–π
3. **–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å:** –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–º–∏
4. **Error Handling:** Comprehensive –æ–±—Ä–∞–±–æ—Ç–∫–∞ blockchain –æ—à–∏–±–æ–∫

## üìö –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã

### Ethereum Integration Stack

- **–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞:** `ethers-rs` v2.0+ - —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è async Ethereum library
- **Testnet:** Sepolia (Chain ID: 11155111) - —Å—Ç–∞–±–∏–ª—å–Ω–∞—è —Ç–µ—Å—Ç–æ–≤–∞—è —Å–µ—Ç—å
- **RPC Provider:** Infura –∏–ª–∏ Alchemy –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
- **Wallet Management:** LocalWallet —Å quantum-protected storage

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∞–¥–∞–ø—Ç–µ—Ä–∞

```mermaid
graph TB
    subgraph "Phase 4.1: Ethereum Adapter"
        A[EthereumAdapter] --> B[Provider Management]
        A --> C[Wallet Operations]
        A --> D[Contract Interactions]
        
        B --> E[Sepolia RPC]
        C --> F[Transaction Signing]
        C --> G[Balance Monitoring]
        D --> H[ERC-20 Contracts]
        D --> I[Event Listeners]
        
        F --> J[Quantum Protection]
        G --> K[Health Monitoring]
    end
    
    L[Phase 3: Quantum Crypto] --> J
    M[Bridge Service] -.->|Phase 4.3| A
    N[AI Risk Engine] -.->|Phase 5| A
```

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ kembridge-blockchain crate

```
backend/crates/kembridge-blockchain/
‚îú‚îÄ‚îÄ Cargo.toml                    # ethers-rs –∏ blockchain –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs                    # –ü—É–±–ª–∏—á–Ω—ã–π API –º–æ–¥—É–ª—è
‚îÇ   ‚îú‚îÄ‚îÄ ethereum/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs               # Ethereum –º–æ–¥—É–ª—å
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter.rs           # EthereumAdapter –æ—Å–Ω–æ–≤–Ω–æ–π
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contracts.rs         # ERC-20 –∏ –¥—Ä—É–≥–∏–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet.rs            # Wallet management —Å quantum –∑–∞—â–∏—Ç–æ–π
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events.rs            # Event listeners –∏ monitoring
‚îÇ   ‚îú‚îÄ‚îÄ near/                    # –î–ª—è Phase 4.2
‚îÇ   ‚îú‚îÄ‚îÄ error.rs                 # Blockchain-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏
‚îÇ   ‚îî‚îÄ‚îÄ config.rs                # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–µ—Ç–µ–π
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ ethereum_tests.rs        # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
    ‚îî‚îÄ‚îÄ mock_contracts.rs        # Mock –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–π backend

```
backend/src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ blockchain.rs            # BlockchainService –¥–ª—è API endpoints
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îî‚îÄ‚îÄ ethereum.rs              # HTTP handlers –¥–ª—è /api/v1/ethereum/*
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ blockchain.rs            # –†–æ—É—Ç—ã –¥–ª—è blockchain endpoints
‚îî‚îÄ‚îÄ models/
    ‚îî‚îÄ‚îÄ blockchain.rs            # –ú–æ–¥–µ–ª–∏ –¥–ª—è blockchain –æ–ø–µ—Ä–∞—Ü–∏–π
```

## üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

### 4.1.1 –î–æ–±–∞–≤–ª–µ–Ω–∏–µ ethers-rs –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –±–∞–∑–æ–≤—ã–µ blockchain –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

```toml
# backend/crates/kembridge-blockchain/Cargo.toml
[dependencies]
ethers = { version = "2.0", features = ["rustls", "ws"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
anyhow = "1.0"
tracing = "0.1"
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }

# –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å kembridge-crypto –¥–ª—è –∑–∞—â–∏—Ç—ã –∫–ª—é—á–µ–π
kembridge-crypto = { path = "../kembridge-crypto" }
```

### 4.1.2 –°–æ–∑–¥–∞–Ω–∏–µ EthereumAdapter —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –æ—Å–Ω–æ–≤–Ω–æ–π –∞–¥–∞–ø—Ç–µ—Ä

```rust
// kembridge-blockchain/src/ethereum/adapter.rs
use ethers::{
    providers::{Provider, Http, Middleware},
    types::{Address, U256, TransactionRequest, H256},
    signers::{LocalWallet, Signer},
};
use std::sync::Arc;
use kembridge_crypto::QuantumKeyManager;

pub struct EthereumAdapter {
    provider: Arc<Provider<Http>>,
    chain_id: u64,
    quantum_manager: QuantumKeyManager,
    config: EthereumConfig,
}

#[derive(Debug, Clone)]
pub struct EthereumConfig {
    pub rpc_url: String,
    pub chain_id: u64,
    pub gas_price_multiplier: f64,
    pub confirmation_blocks: u64,
    pub max_retry_attempts: u32,
}

impl EthereumAdapter {
    /// –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ Ethereum –∞–¥–∞–ø—Ç–µ—Ä–∞ –¥–ª—è Sepolia
    pub async fn new(config: EthereumConfig) -> Result<Self, EthereumError> {
        let provider = Provider::<Http>::try_from(&config.rpc_url)
            .map_err(|e| EthereumError::ConnectionFailed(e.to_string()))?;
        
        let provider = Arc::new(provider);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å–µ—Ç–∏
        let network_id = provider.get_chainid().await
            .map_err(|e| EthereumError::NetworkError(e.to_string()))?;
        
        if network_id.as_u64() != config.chain_id {
            return Err(EthereumError::InvalidNetwork {
                expected: config.chain_id,
                actual: network_id.as_u64(),
            });
        }

        Ok(Self {
            provider,
            chain_id: config.chain_id,
            quantum_manager: QuantumKeyManager::new(),
            config,
        })
    }
}
```

### 4.1.3 –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Sepolia testnet

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - testnet –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

```rust
// kembridge-blockchain/src/ethereum/config.rs
impl EthereumConfig {
    /// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è Sepolia testnet
    pub fn sepolia() -> Self {
        Self {
            rpc_url: std::env::var("ETHEREUM_RPC_URL")
                .unwrap_or_else(|_| "https://sepolia.infura.io/v3/YOUR_INFURA_KEY".to_string()),
            chain_id: 11155111, // Sepolia Chain ID
            gas_price_multiplier: 1.2, // 20% –∑–∞–ø–∞—Å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
            confirmation_blocks: 2, // –ë—ã—Å—Ç—Ä—ã–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤ testnet
            max_retry_attempts: 3,
        }
    }
    
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    pub fn validate(&self) -> Result<(), EthereumError> {
        if self.chain_id != 11155111 {
            return Err(EthereumError::InvalidNetwork {
                expected: 11155111,
                actual: self.chain_id,
            });
        }
        
        if !self.rpc_url.starts_with("https://") {
            return Err(EthereumError::InvalidConfiguration(
                "RPC URL must use HTTPS".to_string()
            ));
        }
        
        Ok(())
    }
}
```

### 4.1.4 –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ ETH —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –±–∞–∑–æ–≤—ã–µ ETH –æ–ø–µ—Ä–∞—Ü–∏–∏

```rust
impl EthereumAdapter {
    /// –û—Ç–ø—Ä–∞–≤–∫–∞ ETH —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å quantum-protected wallet
    pub async fn send_eth(
        &self,
        from_private_key_id: uuid::Uuid,
        to: Address,
        amount: U256,
        user_id: uuid::Uuid,
    ) -> Result<H256, EthereumError> {
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ —á–µ—Ä–µ–∑ quantum crypto
        let private_key = self.get_decrypted_private_key(from_private_key_id, user_id).await?;
        
        let wallet = LocalWallet::from_bytes(&private_key)
            .map_err(|e| EthereumError::WalletError(e.to_string()))?
            .with_chain_id(self.chain_id);
        
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç–∏ —Å—Ä–µ–¥—Å—Ç–≤
        let balance = self.provider.get_balance(wallet.address(), None).await
            .map_err(|e| EthereumError::NetworkError(e.to_string()))?;
        
        if balance < amount {
            return Err(EthereumError::InsufficientFunds {
                available: balance,
                required: amount,
            });
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        let tx = TransactionRequest::new()
            .to(to)
            .value(amount)
            .gas_price(self.estimate_gas_price().await?);
        
        // –ü–æ–¥–ø–∏—Å–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞
        let signed_tx = wallet.sign_transaction(&tx).await
            .map_err(|e| EthereumError::SigningFailed(e.to_string()))?;
        
        let tx_hash = self.provider.send_raw_transaction(signed_tx).await
            .map_err(|e| EthereumError::TransactionFailed(e.to_string()))?;
        
        tracing::info!(
            tx_hash = %tx_hash,
            from = %wallet.address(),
            to = %to,
            amount = %amount,
            "ETH transaction sent"
        );
        
        Ok(tx_hash)
    }
    
    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –∏–∑ quantum storage
    async fn get_decrypted_private_key(
        &self,
        key_id: uuid::Uuid,
        user_id: uuid::Uuid,
    ) -> Result<Vec<u8>, EthereumError> {
        // TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å QuantumService –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –∫–ª—é—á–µ–π
        // –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
        tracing::warn!("Using mock private key - implement quantum decryption in Phase 4.3");
        
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:
        // 1. –ü–æ–ª—É—á–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á –∏–∑ quantum_keys —Ç–∞–±–ª–∏—Ü—ã
        // 2. –ò—Å–ø–æ–ª—å–∑—É–µ–º quantum crypto –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏
        // 3. –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π private key
        
        Ok(vec![0u8; 32]) // Mock private key
    }
}
```

### 4.1.5 –°–æ–∑–¥–∞–Ω–∏–µ mock ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚è∏Ô∏è –û–¢–õ–û–ñ–ï–ù–û –¥–æ Phase 4.3 - —Ç—Ä–µ–±—É–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å bridge logic

**–ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–ª–æ–∂–µ–Ω–∏—è:** Mock ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç —Ç–µ—Å–Ω–æ —Å–≤—è–∑–∞–Ω —Å bridge –º–µ—Ö–∞–Ω–∏–∑–º–∞–º–∏ –∏ –±—É–¥–µ—Ç –ª—É—á—à–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω–æ–π bridge –ª–æ–≥–∏–∫–æ–π –≤ Phase 4.3.

### 4.1.6 –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å ERC-20 —Ç–æ–∫–µ–Ω–∞–º–∏

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –±–∞–∑–æ–≤–∞—è ERC-20 –ø–æ–¥–¥–µ—Ä–∂–∫–∞

```rust
// kembridge-blockchain/src/ethereum/contracts.rs
use ethers::{
    contract::{Contract, ContractFactory},
    abi::{Abi, Token},
    types::{Address, U256},
};

pub struct ERC20Contract {
    contract: Contract<Provider<Http>>,
    address: Address,
}

impl ERC20Contract {
    /// –°–æ–∑–¥–∞–Ω–∏–µ ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    pub async fn new(
        provider: Arc<Provider<Http>>,
        address: Address,
    ) -> Result<Self, EthereumError> {
        // Standard ERC-20 ABI
        let abi: Abi = serde_json::from_str(include_str!("../abis/erc20.json"))
            .map_err(|e| EthereumError::ContractError(e.to_string()))?;
        
        let contract = Contract::new(address, abi, provider);
        
        Ok(Self { contract, address })
    }
    
    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ —Ç–æ–∫–µ–Ω–æ–≤
    pub async fn balance_of(&self, owner: Address) -> Result<U256, EthereumError> {
        let balance: U256 = self.contract
            .method::<_, U256>("balanceOf", owner)?
            .call()
            .await
            .map_err(|e| EthereumError::ContractError(e.to_string()))?;
        
        Ok(balance)
    }
    
    /// Transfer —Ç–æ–∫–µ–Ω–æ–≤
    pub async fn transfer(
        &self,
        wallet: &LocalWallet,
        to: Address,
        amount: U256,
    ) -> Result<H256, EthereumError> {
        let contract_with_signer = self.contract.connect(wallet.clone());
        
        let tx = contract_with_signer
            .method::<_, H256>("transfer", (to, amount))?
            .send()
            .await
            .map_err(|e| EthereumError::ContractError(e.to_string()))?;
        
        Ok(tx.tx_hash())
    }
}
```

### 4.1.7 –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –±–∞–ª–∞–Ω—Å–∞ –∫–æ—à–µ–ª—å–∫–æ–≤

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è bridge –æ–ø–µ—Ä–∞—Ü–∏–π

```rust
impl EthereumAdapter {
    /// –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–∞–ª–∞–Ω—Å–∞ ETH –∫–æ—à–µ–ª—å–∫–∞
    pub async fn get_eth_balance(&self, address: Address) -> Result<U256, EthereumError> {
        let balance = self.provider.get_balance(address, None).await
            .map_err(|e| EthereumError::NetworkError(e.to_string()))?;
        
        Ok(balance)
    }
    
    /// –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–∞–ª–∞–Ω—Å–∞ ERC-20 —Ç–æ–∫–µ–Ω–æ–≤
    pub async fn get_token_balance(
        &self,
        token_address: Address,
        wallet_address: Address,
    ) -> Result<U256, EthereumError> {
        let erc20 = ERC20Contract::new(self.provider.clone(), token_address).await?;
        erc20.balance_of(wallet_address).await
    }
    
    /// –ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∫–æ—à–µ–ª—å–∫–∞
    pub async fn get_wallet_info(
        &self,
        address: Address,
        token_addresses: Vec<Address>,
    ) -> Result<WalletInfo, EthereumError> {
        let eth_balance = self.get_eth_balance(address).await?;
        let nonce = self.provider.get_transaction_count(address, None).await
            .map_err(|e| EthereumError::NetworkError(e.to_string()))?;
        
        let mut token_balances = Vec::new();
        for token_addr in token_addresses {
            match self.get_token_balance(token_addr, address).await {
                Ok(balance) => token_balances.push(TokenBalance {
                    token_address: token_addr,
                    balance,
                }),
                Err(e) => tracing::warn!(
                    token = %token_addr,
                    error = %e,
                    "Failed to get token balance"
                ),
            }
        }
        
        Ok(WalletInfo {
            address,
            eth_balance,
            nonce,
            token_balances,
            last_updated: chrono::Utc::now(),
        })
    }
}

#[derive(Debug, Clone)]
pub struct WalletInfo {
    pub address: Address,
    pub eth_balance: U256,
    pub nonce: U256,
    pub token_balances: Vec<TokenBalance>,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct TokenBalance {
    pub token_address: Address,
    pub balance: U256,
}
```

### 4.1.8 –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚úÖ –†–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –≤ Phase 4.1 - –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏

```rust
impl EthereumAdapter {
    /// –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    pub async fn wait_for_confirmation(
        &self,
        tx_hash: H256,
    ) -> Result<TransactionReceipt, EthereumError> {
        let receipt = self.provider
            .pending_transaction(tx_hash)
            .await
            .map_err(|e| EthereumError::TransactionFailed(e.to_string()))?
            .confirmations(self.config.confirmation_blocks)
            .await
            .map_err(|e| EthereumError::ConfirmationFailed(e.to_string()))?
            .ok_or(EthereumError::TransactionNotFound(tx_hash))?;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        if receipt.status != Some(1.into()) {
            return Err(EthereumError::TransactionReverted {
                tx_hash,
                gas_used: receipt.gas_used.unwrap_or_default(),
            });
        }
        
        tracing::info!(
            tx_hash = %tx_hash,
            block_number = %receipt.block_number.unwrap_or_default(),
            gas_used = %receipt.gas_used.unwrap_or_default(),
            "Transaction confirmed"
        );
        
        Ok(receipt)
    }
    
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è
    pub async fn get_transaction_status(
        &self,
        tx_hash: H256,
    ) -> Result<TransactionStatus, EthereumError> {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –±–ª–æ–∫—á–µ–π–Ω–µ
        match self.provider.get_transaction(tx_hash).await {
            Ok(Some(tx)) => {
                // –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–∞–π–¥–µ–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º receipt
                match self.provider.get_transaction_receipt(tx_hash).await {
                    Ok(Some(receipt)) => {
                        let confirmations = self.provider.get_block_number().await
                            .map_err(|e| EthereumError::NetworkError(e.to_string()))?
                            .saturating_sub(receipt.block_number.unwrap_or_default())
                            + 1;
                        
                        Ok(TransactionStatus::Confirmed {
                            receipt,
                            confirmations: confirmations.as_u64(),
                        })
                    },
                    Ok(None) => Ok(TransactionStatus::Pending { transaction: tx }),
                    Err(e) => Err(EthereumError::NetworkError(e.to_string())),
                }
            },
            Ok(None) => Ok(TransactionStatus::NotFound),
            Err(e) => Err(EthereumError::NetworkError(e.to_string())),
        }
    }
}

#[derive(Debug, Clone)]
pub enum TransactionStatus {
    NotFound,
    Pending { transaction: Transaction },
    Confirmed { receipt: TransactionReceipt, confirmations: u64 },
}
```

### 4.1.9 –°–æ–∑–¥–∞–Ω–∏–µ event listeners –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚è∏Ô∏è –û–¢–õ–û–ñ–ï–ù–û –¥–æ Phase 4.3 - —Ç—Ä–µ–±—É–µ—Ç BridgeService –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏

**–ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–ª–æ–∂–µ–Ω–∏—è:** Event listeners —Ç–µ—Å–Ω–æ —Å–≤—è–∑–∞–Ω—ã —Å bridge workflow –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º –æ–ø–µ—Ä–∞—Ü–∏–π –º–æ—Å—Ç–∞. –ë—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤–º–µ—Å—Ç–µ —Å –æ—Å–Ω–æ–≤–Ω–æ–π bridge –ª–æ–≥–∏–∫–æ–π.

## üîÑ –°–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ —Ñ–∞–∑–∞–º–∏

### –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ Phase 4.1

**–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:** ‚è∏Ô∏è –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ Phase 4.3 - —Ç—Ä–µ–±—É–µ—Ç BridgeService

- **4.1.5** –°–æ–∑–¥–∞–Ω–∏–µ mock ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ ‚Üí Phase 4.3.2 (—Å–≤—è–∑–∞–Ω–æ —Å lock/unlock –º–µ—Ö–∞–Ω–∏–∑–º–æ–º)
- **4.1.9** Event listeners ‚Üí Phase 4.3.6 (—Å–≤—è–∑–∞–Ω–æ —Å atomic swap monitoring)

**–ü—Ä–∏—á–∏–Ω—ã –ø–µ—Ä–µ–Ω–æ—Å–∞:**

1. Mock ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–æ–ª–∂–µ–Ω —É—á–∏—Ç—ã–≤–∞—Ç—å bridge –º–µ—Ö–∞–Ω–∏–∑–º—ã
2. Event listeners —Ç—Ä–µ–±—É—é—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å BridgeService workflow
3. Phase 4.1 —Ñ–æ–∫—É—Å–∏—Ä—É–µ—Ç—Å—è –Ω–∞ –±–∞–∑–æ–≤–æ–π Ethereum —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏

### –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥—Ä—É–≥–∏—Ö —Ñ–∞–∑

- **Phase 3.4:** QuantumCrypto –¥–ª—è –∑–∞—â–∏—Ç—ã –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–ª—é—á–µ–π ‚úÖ
- **Phase 4.3:** BridgeService –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π
- **Phase 5.2:** AI Risk Engine –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
- **Phase 2.1:** AuthUser –¥–ª—è —Å–≤—è–∑—ã–≤–∞–Ω–∏—è wallet addresses ‚úÖ

### –û–±—Ä–∞—Ç–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º—ã—Ö —Ñ–∞–∑–∞—Ö

–í Phase 4.3 –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏:
- **4.3.2** üîó –ó–∞–≤–µ—Ä—à–∏—Ç –∑–∞–¥–∞—á—É 4.1.5 - —Å–æ–∑–¥–∞–Ω–∏–µ ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–ª—è lock/unlock
- **4.3.6** üîó –ó–∞–≤–µ—Ä—à–∏—Ç –∑–∞–¥–∞—á—É 4.1.9 - event listeners –¥–ª—è atomic swap monitoring

## üìä –ö—Ä–∏—Ç–µ—Ä–∏–∏ —É—Å–ø–µ—Ö–∞ Phase 4.1

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:

- [ ] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Sepolia testnet —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] –û—Ç–ø—Ä–∞–≤–∫–∞ ETH —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —É—Å–ø–µ—à–Ω–∞
- [ ] –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–∞–ª–∞–Ω—Å–æ–≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç
- [ ] –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] ERC-20 –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (balance, transfer)
- [ ] Quantum-protected wallet integration
- [ ] Comprehensive error handling

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:

- [ ] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ RPC < 1s
- [ ] –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ < 500ms
- [ ] –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ < 2s
- [ ] –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ < 30s (Sepolia)

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:

- [ ] –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–ª—é—á–∏ –∑–∞—â–∏—â–µ–Ω—ã quantum crypto
- [ ] Validation –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
- [ ] Secure RPC connections (HTTPS only)
- [ ] Transaction replay protection

## ‚ö†Ô∏è –í–∞–∂–Ω—ã–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è

1. **Testnet Only:** –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å mainnet –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
2. **Private Keys:** –í—Å–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–ª—é—á–∏ –¥–æ–ª–∂–Ω—ã —Ö—Ä–∞–Ω–∏—Ç—å—Å—è encrypted —á–µ—Ä–µ–∑ quantum crypto
3. **Gas Limits:** –í—Å–µ–≥–¥–∞ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å reasonable gas limits
4. **Error Handling:** –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å network failures gracefully

## üöÄ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Phase 4.1:

1. **Phase 4.2:** NEAR Protocol Adapter - –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
2. **Phase 4.3:** Basic Bridge Logic - –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ ETH –∏ NEAR –∞–¥–∞–ø—Ç–µ—Ä–æ–≤
3. **Phase 5.2:** AI Risk Integration - –∞–Ω–∞–ª–∏–∑ Ethereum —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
4. **Phase 6.1:** Price Oracle - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Chainlink –¥–ª—è ETH/USD

---

**–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç Phase 4.1:** –†–∞–±–æ—Ç–∞—é—â–∏–π Ethereum –∞–¥–∞–ø—Ç–µ—Ä —Å quantum-protected wallet management, –≥–æ—Ç–æ–≤—ã–π –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤ –∫—Ä–æ—Å—Å-—á–µ–π–Ω –º–æ—Å—Ç.