# Phase 4.2: NEAR Protocol Adapter Implementation Guide

## üìã –û–±–∑–æ—Ä —Ñ–∞–∑—ã

**–¶–µ–ª—å:** –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–≥–æ –∞–¥–∞–ø—Ç–µ—Ä–∞ –¥–ª—è NEAR Protocol —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π Chain Signatures –∏ 1Click API –¥–ª—è –∫—Ä–æ—Å—Å-—á–µ–π–Ω –æ–ø–µ—Ä–∞—Ü–∏–π
**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** Phase 4.1 (Ethereum Adapter), Phase 3.x (Quantum Cryptography), Phase 2.1.5 (NEAR ed25519 signatures)
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞—é—â–∏–π NEAR –∞–¥–∞–ø—Ç–µ—Ä —Å Chain Signatures, 1Click API –∏ quantum-–∑–∞—â–∏—â–µ–Ω–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏

## üéØ –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **Chain Signatures Integration:** –ò—Å–ø–æ–ª—å–∑—É–µ–º NEAR MPC –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ –¥—Ä—É–≥–∏—Ö –±–ª–æ–∫—á–µ–π–Ω–∞—Ö
2. **1Click API:** –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π UX –¥–ª—è cross-chain –æ–ø–µ—Ä–∞—Ü–∏–π —á–µ—Ä–µ–∑ intent-based swaps
3. **WebAssembly Smart Contracts:** –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ bridge –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ –Ω–∞ NEAR
4. **Quantum Protection:** –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å kembridge-crypto –¥–ª—è –∑–∞—â–∏—Ç—ã NEAR –æ–ø–µ—Ä–∞—Ü–∏–π

## üìö –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã

### NEAR Chain Signatures

- **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:** https://docs.near.org/chain-abstraction/chain-signatures
- **–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è:** Multi-Party Computation (MPC) –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
- **Derivation Paths:** –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–¥—Ä–µ—Å–æ–≤ –≤ –¥—Ä—É–≥–∏—Ö –±–ª–æ–∫—á–µ–π–Ω–∞—Ö
- **MPC Contract:** `v1.signer` –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ signature requests
- **Cross-chain Support:** Bitcoin, Ethereum, –∏ –¥—Ä—É–≥–∏–µ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –±–ª–æ–∫—á–µ–π–Ω—ã
- **Implementation Guide:** https://docs.near.org/chain-abstraction/chain-signatures/implementation

### NEAR 1Click API

- **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:** https://docs.near-intents.org/near-intents/integration/distribution-channels/1click-api
- **Intent-based Swaps:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ cross-chain –æ–ø–µ—Ä–∞—Ü–∏–π
- **Solver Network:** –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–µ —Ü–µ–Ω–æ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
- **API Endpoints:** `/v0/quote`, `/v0/deposit/submit`, `/v0/status`
- **SDK Support:** TypeScript, Go, Rust

### NEAR Smart Contracts

- **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:** https://docs.near.org/smart-contracts/what-is
- **Anatomy Guide:** https://docs.near.org/smart-contracts/anatomy/
- **WebAssembly:** –ö–æ–º–ø–∏–ª—è—Ü–∏—è Rust –∏ JavaScript –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
- **Account Model:** –°–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã –∂–∏–≤—É—Ç –≤ NEAR –∞–∫–∫–∞—É–Ω—Ç–∞—Ö
- **Cross-contract Calls:** –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –º–µ–∂–¥—É –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞–º–∏
- **Low Deployment Costs:** ~1 NEAR –∑–∞ 100kb storage

### NEAR Development Tools

- **NEAR CLI:** https://docs.near.org/tools/near-cli
- **Rust SDK:** https://github.com/near/near-sdk-rs
- **Development Environment:** https://docs.near.org/smart-contracts/quickstart

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ NEAR –º–æ–¥—É–ª—è

```
backend/crates/kembridge-blockchain/src/near/
‚îú‚îÄ‚îÄ mod.rs                      # –ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
‚îú‚îÄ‚îÄ adapter.rs                  # NearAdapter - –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
‚îú‚îÄ‚îÄ config.rs                   # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è testnet/mainnet
‚îú‚îÄ‚îÄ chain_signatures.rs         # Chain Signatures MPC –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
‚îú‚îÄ‚îÄ one_click_api.rs           # 1Click API –∫–ª–∏–µ–Ω—Ç
‚îú‚îÄ‚îÄ wallet.rs                   # NEAR wallet management
‚îú‚îÄ‚îÄ contracts.rs                # Bridge —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç
‚îî‚îÄ‚îÄ error.rs                    # NEAR-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å kembridge-crypto

```rust
// –ü—Ä–∏–º–µ—Ä –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ quantum crypto —Å NEAR –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏
use kembridge_crypto::QuantumKeyManager;

impl NearAdapter {
    pub async fn quantum_protected_transfer(
        &self,
        to: &str,
        amount: u128,
        quantum_key_id: &str,
    ) -> Result<TransactionHash, NearError> {
        // Quantum encryption —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        let protected_data = self.quantum_manager
            .protect_transaction_data(&transaction_data)?;
        
        // NEAR —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —Å quantum-–∑–∞—â–∏—â–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
        self.execute_transfer_with_metadata(to, amount, protected_data).await
    }
}
```

## üîß –ü–æ—ç—Ç–∞–ø–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

### –≠—Ç–∞–ø 1: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∏ –∫–æ–º–ø–∏–ª—è—Ü–∏—è

**–¶–µ–ª—å:** –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –≤—Å–µ NEAR –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è

```rust
// Cargo.toml - –±–∞–∑–æ–≤—ã–µ NEAR –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
// –ò—Å—Ç–æ—á–Ω–∏–∫: https://docs.near.org/smart-contracts/quickstart
[dependencies]
near-sdk = "5.2.0"
near-jsonrpc-client = "0.10.0"
near-crypto = "0.24.0"
near-primitives = "0.24.0"

// –î–ª—è Chain Signatures
// –ò—Å—Ç–æ—á–Ω–∏–∫: https://docs.near.org/chain-abstraction/chain-signatures/implementation
workspaces = "0.11.0"

// –î–ª—è 1Click API
// –ò—Å—Ç–æ—á–Ω–∏–∫: https://docs.near-intents.org/near-intents/integration/distribution-channels/1click-api
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
```

```rust
// src/near/mod.rs - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
pub mod adapter;
pub mod config;
pub mod error;

pub use adapter::NearAdapter;
pub use config::NearConfig;
pub use error::NearError;
```

### –≠—Ç–∞–ø 2: –ë–∞–∑–æ–≤–∞—è NearAdapter —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```rust
// src/near/adapter.rs - –æ—Å–Ω–æ–≤–Ω–æ–π –∞–¥–∞–ø—Ç–µ—Ä
// –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞: https://docs.near.org/smart-contracts/anatomy/
use near_jsonrpc_client::{JsonRpcClient, methods};
use kembridge_crypto::QuantumKeyManager;

pub struct NearAdapter {
    rpc_client: JsonRpcClient,
    network_id: String,
    quantum_manager: QuantumKeyManager,
    config: NearConfig,
}

impl NearAdapter {
    pub async fn new(config: NearConfig) -> Result<Self, NearError> {
        let rpc_client = JsonRpcClient::connect(&config.rpc_url);
        
        Ok(Self {
            rpc_client,
            network_id: config.network_id.clone(),
            quantum_manager: QuantumKeyManager::new()?,
            config,
        })
    }

    pub async fn get_network_info(&self) -> Result<(String, u64), NearError> {
        // –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        let status = self.rpc_client
            .call(methods::status::RpcStatusRequest)
            .await?;
            
        Ok((status.chain_id, status.latest_protocol_version))
    }
}
```

### –≠—Ç–∞–ø 3: NEAR Chain Signatures –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

```rust
// src/near/chain_signatures.rs
// –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞: https://docs.near.org/chain-abstraction/chain-signatures/implementation
use workspaces::{Contract, Account};

pub struct ChainSignatureService {
    mpc_contract: Contract,
    derivation_path: String,
}

impl ChainSignatureService {
    pub async fn new(network: &str) -> Result<Self, NearError> {
        let worker = workspaces::sandbox().await?;
        let mpc_contract = worker
            .dev_deploy("v1.signer-dev")
            .await?;
            
        Ok(Self {
            mpc_contract,
            derivation_path: format!("ethereum-{}", network),
        })
    }

    pub async fn derive_ethereum_address(
        &self,
        near_account: &str,
    ) -> Result<String, NearError> {
        // Derivation path –¥–ª—è Ethereum –∞–¥—Ä–µ—Å–∞
        let args = json!({
            "account_id": near_account,
            "derivation_path": self.derivation_path
        });

        let result = self.mpc_contract
            .call("derive_key")
            .args_json(args)
            .transact()
            .await?;

        Ok(result.json::<String>()?)
    }

    pub async fn sign_ethereum_transaction(
        &self,
        transaction_payload: &[u8],
        derivation_path: &str,
    ) -> Result<Vec<u8>, NearError> {
        // MPC –ø–æ–¥–ø–∏—Å–∞–Ω–∏–µ Ethereum —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        let args = json!({
            "payload": base64::encode(transaction_payload),
            "path": derivation_path
        });

        let signature = self.mpc_contract
            .call("sign")
            .args_json(args)
            .transact()
            .await?;

        Ok(signature.json::<Vec<u8>>()?)
    }
}
```

### –≠—Ç–∞–ø 4: 1Click API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

```rust
// src/near/one_click_api.rs
use reqwest::Client;
use serde::{Deserialize, Serialize};

#[derive(Serialize)]
pub struct QuoteRequest {
    pub from_token: String,
    pub to_token: String,
    pub amount: String,
    pub from_address: String,
    pub to_address: String,
}

#[derive(Deserialize)]
pub struct QuoteResponse {
    pub quote_id: String,
    pub deposit_address: String,
    pub expected_output: String,
    pub expires_at: u64,
}

pub struct OneClickApiClient {
    client: Client,
    base_url: String,
    jwt_token: Option<String>,
}

impl OneClickApiClient {
    pub fn new(testnet: bool) -> Self {
        let base_url = if testnet {
            "https://api.testnet.1click.near.org"
        } else {
            "https://api.1click.near.org"
        }.to_string();

        Self {
            client: Client::new(),
            base_url,
            jwt_token: None,
        }
    }

    pub async fn get_quote(&self, request: QuoteRequest) -> Result<QuoteResponse, NearError> {
        let url = format!("{}/v0/quote", self.base_url);
        
        let response = self.client
            .post(&url)
            .json(&request)
            .send()
            .await?;

        let quote = response.json::<QuoteResponse>().await?;
        Ok(quote)
    }

    pub async fn submit_deposit(
        &self,
        quote_id: &str,
        tx_hash: &str,
    ) -> Result<(), NearError> {
        let url = format!("{}/v0/deposit/submit", self.base_url);
        
        let payload = json!({
            "quote_id": quote_id,
            "tx_hash": tx_hash
        });

        self.client
            .post(&url)
            .json(&payload)
            .send()
            .await?;

        Ok(())
    }

    pub async fn check_swap_status(&self, quote_id: &str) -> Result<SwapStatus, NearError> {
        let url = format!("{}/v0/status/{}", self.base_url, quote_id);
        
        let response = self.client
            .get(&url)
            .send()
            .await?;

        let status = response.json::<SwapStatus>().await?;
        Ok(status)
    }
}
```

### –≠—Ç–∞–ø 5: NEAR Bridge Smart Contract

```rust
// contracts/bridge/src/lib.rs - NEAR —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è –º–æ—Å—Ç–∞
// –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞: https://docs.near.org/smart-contracts/anatomy/
// –ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã: https://docs.near.org/smart-contracts/anatomy/functions
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId, Promise};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct BridgeContract {
    pub owner: AccountId,
    pub locked_tokens: std::collections::HashMap<String, u128>,
    pub pending_transfers: std::collections::HashMap<String, PendingTransfer>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PendingTransfer {
    pub from_chain: String,
    pub to_chain: String,
    pub amount: u128,
    pub recipient: String,
    pub quantum_hash: String, // Hash –æ—Ç quantum-protected –¥–∞–Ω–Ω—ã—Ö
    pub expires_at: u64,
}

#[near_bindgen]
impl BridgeContract {
    #[init]
    pub fn new(owner: AccountId) -> Self {
        Self {
            owner,
            locked_tokens: std::collections::HashMap::new(),
            pending_transfers: std::collections::HashMap::new(),
        }
    }

    pub fn lock_tokens_for_bridge(
        &mut self,
        transfer_id: String,
        amount: u128,
        target_chain: String,
        recipient: String,
        quantum_protection: String,
    ) -> Promise {
        // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è cross-chain –ø–µ—Ä–µ–≤–æ–¥–∞
        let transfer = PendingTransfer {
            from_chain: "near".to_string(),
            to_chain: target_chain,
            amount,
            recipient,
            quantum_hash: quantum_protection,
            expires_at: env::block_timestamp() + 3600_000_000_000, // 1 hour
        };

        self.pending_transfers.insert(transfer_id.clone(), transfer);
        self.locked_tokens.insert(transfer_id, amount);

        // Emit event –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        env::log_str(&format!("BRIDGE_LOCK: {}", transfer_id));
        
        Promise::new(env::current_account_id())
    }

    pub fn unlock_tokens(&mut self, transfer_id: String) -> Promise {
        // –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º cross-chain –ø–µ—Ä–µ–≤–æ–¥–µ
        if let Some(amount) = self.locked_tokens.remove(&transfer_id) {
            self.pending_transfers.remove(&transfer_id);
            
            env::log_str(&format!("BRIDGE_UNLOCK: {} amount: {}", transfer_id, amount));
            Promise::new(env::current_account_id())
        } else {
            env::panic_str("Transfer not found or already processed");
        }
    }
}
```

## üß™ –ü–æ—ç—Ç–∞–ø–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –≠—Ç–∞–ø 1: –ö–æ–º–ø–∏–ª—è—Ü–∏—è –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ

```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ NEAR –º–æ–¥—É–ª—è
# –ö–æ–º–∞–Ω–¥—ã –æ—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞: https://docs.near.org/smart-contracts/quickstart
cd backend/crates/kembridge-blockchain
cargo check --features near

# –†–µ–∑—É–ª—å—Ç–∞—Ç: —É—Å–ø–µ—à–Ω–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è –±–µ–∑ –æ—à–∏–±–æ–∫
```

### –≠—Ç–∞–ø 2: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ NearAdapter

```rust
// tests/near_adapter_test.rs
#[tokio::test]
async fn test_near_adapter_connection() {
    let config = NearConfig::testnet();
    let adapter = NearAdapter::new(config).await.unwrap();
    
    let (chain_id, version) = adapter.get_network_info().await.unwrap();
    assert_eq!(chain_id, "testnet");
    assert!(version > 0);
}
```

### –≠—Ç–∞–ø 3: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Chain Signatures

```bash
# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ MPC –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
# –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞: https://docs.near.org/chain-abstraction/chain-signatures/implementation
cargo test test_chain_signatures_ethereum_address -- --nocapture
```

### –≠—Ç–∞–ø 4: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ 1Click API

```bash
# –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å 1Click API testnet
# API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: https://docs.near-intents.org/near-intents/integration/distribution-channels/1click-api
cargo test test_one_click_api_quote -- --nocapture
```

## üìä –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

### –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏

| –ó–∞–¥–∞—á–∞ | –û—Ç–ª–æ–∂–µ–Ω–∞ –≤ | –ü—Ä–∏—á–∏–Ω–∞ | –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å |
|--------|------------|---------|-------------|
| **NEAR WebAssembly Bridge Contract** | Phase 4.3.3 | –¢—Ä–µ–±—É–µ—Ç –ø–æ–ª–Ω—É—é bridge –ª–æ–≥–∏–∫—É | BridgeService |
| **Production Chain Signatures** | Phase 4.3.6 | –ù—É–∂–Ω—ã mainnet MPC –Ω–æ–¥—ã | Production deployment |
| **Advanced 1Click Integration** | Phase 5.2 | –¢—Ä–µ–±—É–µ—Ç AI risk analysis | AI Risk Engine |
| **NEAR ed25519 Verification** | Phase 2.1.5 ‚úÖ | –í—ã–ø–æ–ª–Ω–µ–Ω–æ –≤ —ç—Ç–æ–π —Ñ–∞–∑–µ | - |

### –û–±—Ä–∞—Ç–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

- **Phase 4.3.2:** Mint/burn –º–µ—Ö–∞–Ω–∏–∑–º –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å NearAdapter
- **Phase 4.3.5:** Bridge –æ–ø–µ—Ä–∞—Ü–∏–∏ –±—É–¥—É—Ç protected quantum crypto —á–µ—Ä–µ–∑ NEAR
- **Phase 5.2.4:** AI –∞–Ω–∞–ª–∏–∑ –±—É–¥–µ—Ç –≤–∫–ª—é—á–∞—Ç—å NEAR —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
- **Phase 7.3:** Frontend NEAR Wallet –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

## üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –º–æ–¥—É–ª—è–º–∏

### Quantum Cryptography (Phase 3.x)

```rust
// –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å quantum protection
impl NearAdapter {
    pub async fn quantum_protected_chain_signature(
        &self,
        ethereum_tx: &[u8],
        quantum_key_id: &str,
    ) -> Result<Vec<u8>, NearError> {
        // 1. Quantum encryption Ethereum —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        let protected_tx = self.quantum_manager
            .protect_cross_chain_data(ethereum_tx, quantum_key_id)?;
        
        // 2. Chain Signatures –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
        let signature = self.chain_signatures
            .sign_ethereum_transaction(&protected_tx.payload, "ethereum-sepolia")
            .await?;
            
        Ok(signature)
    }
}
```

### Ethereum Adapter Integration (Phase 4.1)

```rust
// Cross-chain –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–µ–∂–¥—É ETH –∏ NEAR
pub async fn cross_chain_transfer(
    ethereum_adapter: &EthereumAdapter,
    near_adapter: &NearAdapter,
    amount: u128,
) -> Result<TransactionHash, BridgeError> {
    // 1. Lock tokens –Ω–∞ Ethereum
    let lock_tx = ethereum_adapter.lock_tokens_for_bridge(amount).await?;
    
    // 2. Chain Signatures –¥–ª—è NEAR –æ–ø–µ—Ä–∞—Ü–∏–∏
    let near_address = near_adapter.chain_signatures
        .derive_ethereum_address("bridge.testnet")
        .await?;
    
    // 3. Mint wrapped tokens –Ω–∞ NEAR
    let mint_tx = near_adapter.mint_wrapped_tokens(amount, &near_address).await?;
    
    Ok(mint_tx)
}
```

## üìà –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

### –ü–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ Phase 4.2

- ‚úÖ **–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π NEAR –∞–¥–∞–ø—Ç–µ—Ä** —Å testnet –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º
- ‚úÖ **Chain Signatures –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è** –¥–ª—è cross-chain –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
- ‚úÖ **1Click API –∫–ª–∏–µ–Ω—Ç** –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–Ω—ã—Ö —Å–≤–∞–ø–æ–≤
- ‚úÖ **NEAR Bridge –∫–æ–Ω—Ç—Ä–∞–∫—Ç** –¥–ª—è lock/unlock –º–µ—Ö–∞–Ω–∏–∑–º–∞
- ‚úÖ **Quantum protection** –¥–ª—è –≤—Å–µ—Ö NEAR –æ–ø–µ—Ä–∞—Ü–∏–π
- ‚úÖ **ed25519 –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è** –¥–ª—è NEAR –ø–æ–¥–ø–∏—Å–µ–π (Phase 2.1.5)

### –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ Phase 4.3

```mermaid
graph TB
    subgraph "Phase 4.2: NEAR Adapter - –ì–û–¢–û–í–û"
        A[NearAdapter] --> B[Chain Signatures]
        A --> C[1Click API]
        A --> D[NEAR Bridge Contract]
        E[Quantum Manager] --> A
    end
    
    subgraph "Phase 4.3: Bridge Logic"
        F[BridgeService] --> A
        F --> G[ETH-NEAR Atomic Swaps]
        H[Quantum Protected Operations] --> F
    end
    
    style A fill:#90EE90
    style B fill:#90EE90
    style C fill:#90EE90
    style D fill:#90EE90
    style E fill:#90EE90
```

## üìñ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

### –û—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è NEAR

- **Chain Abstraction Overview:** https://docs.near.org/chain-abstraction/what-is
- **Smart Contracts Quickstart:** https://docs.near.org/smart-contracts/quickstart
- **Cross-Contract Calls:** https://docs.near.org/smart-contracts/anatomy/crosscontract
- **Environment Variables:** https://docs.near.org/smart-contracts/anatomy/environment
- **Collections API:** https://docs.near.org/smart-contracts/anatomy/collections
- **Serialization:** https://docs.near.org/smart-contracts/anatomy/serialization

### –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

- **NEAR CLI Documentation:** https://docs.near.org/tools/near-cli
- **Rust SDK Repository:** https://github.com/near/near-sdk-rs
- **Workspaces (Testing):** https://github.com/near/workspaces-rs

### –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç—É—Ç–æ—Ä–∏–∞–ª—ã

- **Hello NEAR Examples:** https://github.com/near-examples/hello-near-examples
- **NFT Tutorial:** https://docs.near.org/tutorials/nfts/introduction
- **FT Tutorial:** https://docs.near.org/tutorials/fts/introduction
- **Cross-Contract Call Examples:** https://docs.near.org/tutorials/examples/xcc

---

**Phase 4.2 Status:** –ì–æ—Ç–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π NEAR Protocol, Chain Signatures, 1Click API –∏ quantum cryptography –∑–∞—â–∏—Ç–æ–π. –°–∏—Å—Ç–µ–º–∞ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–∞ –¥–ª—è Phase 4.3 Bridge Logic implementation.