# Phase 4.3: Basic Bridge Logic Implementation Guide

## üìã –û–±–∑–æ—Ä —Ñ–∞–∑—ã

**–¶–µ–ª—å:** –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Å–Ω–æ–≤–Ω–æ–π –ª–æ–≥–∏–∫–∏ –∫—Ä–æ—Å—Å-—á–µ–π–Ω –º–æ—Å—Ç–∞ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö –∏ –∞—Ç–æ–º–∞—Ä–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –º–µ–∂–¥—É Ethereum –∏ NEAR Protocol  
**–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:** Phase 4.1 (Ethereum Adapter), Phase 4.2 (NEAR Protocol Adapter), Phase 3.x (Quantum Cryptography)  
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞—é—â–∏–π –±–∞–∑–æ–≤—ã–π –º–æ—Å—Ç —Å –∫–≤–∞–Ω—Ç–æ–≤–æ–π –∑–∞—â–∏—Ç–æ–π –¥–ª—è ETH ‚Üí NEAR –æ–ø–µ—Ä–∞—Ü–∏–π

## üéØ –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **Atomic Operations:** –í—Å–µ bridge –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∞—Ç–æ–º–∞—Ä–Ω—ã–º–∏ (–ª–∏–±–æ —É—Å–ø–µ—à–Ω—ã–µ, –ª–∏–±–æ –æ—Ç–∫–∞—Ç—ã–≤–∞—é—Ç—Å—è)
2. **Quantum Security:** –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ML-KEM-1024 –¥–ª—è –∑–∞—â–∏—Ç—ã –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
3. **Chain Signatures:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ NEAR MPC –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è Ethereum –∞–∫—Ç–∏–≤–∞–º–∏
4. **Timeout Protection:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –æ—Ç–∫–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–π –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –æ–∂–∏–¥–∞–Ω–∏—è
5. **Comprehensive Logging:** –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –≤ –ë–î –¥–ª—è –∞—É–¥–∏—Ç–∞ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

## üìö –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã

### Cross-Chain Bridge Architecture

- **Lock/Unlock Pattern:** –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ –∏—Å—Ö–æ–¥–Ω–æ–º –±–ª–æ–∫—á–µ–π–Ω–µ
- **Mint/Burn Pattern:** –°–æ–∑–¥–∞–Ω–∏–µ/—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ wrapped —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ —Ü–µ–ª–µ–≤–æ–º –±–ª–æ–∫—á–µ–π–Ω–µ  
- **Atomic Swap Logic:** –ì–∞—Ä–∞–Ω—Ç–∏—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–π —á–µ—Ä–µ–∑ state machine
- **Event-Driven Architecture:** –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ blockchain —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏

### Quantum-Protected Bridge Operations

- **Transaction Encryption:** –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ sensitive –¥–∞–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
- **Key Rotation:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è quantum –∫–ª—é—á–µ–π –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- **Integrity Verification:** HMAC-SHA256 –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
- **Secure Key Exchange:** HKDF –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏ –º–µ–∂–¥—É —Ü–µ–ø—è–º–∏

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ Bridge Service

```
backend/crates/kembridge-bridge/src/
‚îú‚îÄ‚îÄ lib.rs                      # –ü—É–±–ª–∏—á–Ω—ã–π API –º–æ–¥—É–ª—è
‚îú‚îÄ‚îÄ service.rs                  # BridgeService - –æ—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
‚îú‚îÄ‚îÄ swap_engine.rs              # Atomic swap –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è
‚îú‚îÄ‚îÄ state_machine.rs            # State management –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π
‚îú‚îÄ‚îÄ validation.rs               # –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
‚îú‚îÄ‚îÄ timeout_manager.rs          # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–∞—É—Ç–∞–º–∏ –∏ –æ—Ç–∫–∞—Ç–∞–º–∏
‚îú‚îÄ‚îÄ event_handler.rs            # –û–±—Ä–∞–±–æ—Ç–∫–∞ blockchain —Å–æ–±—ã—Ç–∏–π
‚îú‚îÄ‚îÄ quantum_bridge.rs           # Quantum crypto –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
‚îî‚îÄ‚îÄ error.rs                    # Bridge-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏

```rust
// –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ñ–∞–∑
use kembridge_crypto::QuantumKeyManager;        // Phase 3.x
use kembridge_blockchain::EthereumAdapter;      // Phase 4.1
use kembridge_blockchain::NearAdapter;          // Phase 4.2
use kembridge_database::models::Transaction;    // Phase 1.2
use kembridge_auth::AuthUser;                   // Phase 2.x
```

## üîß –ü–æ—ç—Ç–∞–ø–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

### –≠—Ç–∞–ø 1: –°–æ–∑–¥–∞–Ω–∏–µ kembridge-bridge crate

**–¶–µ–ª—å:** –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π crate –¥–ª—è bridge –ª–æ–≥–∏–∫–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

```toml
# Cargo.toml - kembridge-bridge dependencies
[package]
name = "kembridge-bridge"
version = "0.1.0"
edition = "2021"

[dependencies]
# –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
kembridge-crypto = { path = "../kembridge-crypto" }
kembridge-blockchain = { path = "../kembridge-blockchain" }
kembridge-database = { path = "../kembridge-database" }
kembridge-auth = { path = "../kembridge-auth" }

# Async runtime
tokio = { version = "1.46", features = ["full"] }
futures = "0.3"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.10", features = ["v4", "serde"] }

# Time management
chrono = { version = "0.4", features = ["serde"] }

# Error handling
thiserror = "2.0"
anyhow = "1.0"

# Logging
tracing = "0.1"

# Database
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }
```

### –≠—Ç–∞–ø 2: –ë–∞–∑–æ–≤–∞—è BridgeService —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```rust
// src/service.rs - –æ—Å–Ω–æ–≤–Ω–æ–π —Å–µ—Ä–≤–∏—Å
use crate::{SwapEngine, StateMachine, ValidationService, TimeoutManager};
use kembridge_crypto::QuantumKeyManager;
use kembridge_blockchain::{EthereumAdapter, NearAdapter};
use kembridge_database::DbPool;

pub struct BridgeService {
    ethereum_adapter: EthereumAdapter,
    near_adapter: NearAdapter,
    quantum_manager: QuantumKeyManager,
    swap_engine: SwapEngine,
    state_machine: StateMachine,
    validation_service: ValidationService,
    timeout_manager: TimeoutManager,
    db_pool: DbPool,
}

impl BridgeService {
    pub async fn new(
        ethereum_adapter: EthereumAdapter,
        near_adapter: NearAdapter,
        quantum_manager: QuantumKeyManager,
        db_pool: DbPool,
    ) -> Result<Self, BridgeError> {
        Ok(Self {
            ethereum_adapter,
            near_adapter,
            quantum_manager: quantum_manager.clone(),
            swap_engine: SwapEngine::new(quantum_manager.clone()).await?,
            state_machine: StateMachine::new(),
            validation_service: ValidationService::new(),
            timeout_manager: TimeoutManager::new(),
            db_pool,
        })
    }

    pub async fn init_swap(
        &self,
        user_id: uuid::Uuid,
        from_chain: &str,
        to_chain: &str,
        amount: u128,
        recipient: &str,
    ) -> Result<SwapInitResponse, BridgeError> {
        // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        self.validation_service.validate_swap_params(
            from_chain, to_chain, amount, recipient
        ).await?;

        // –°–æ–∑–¥–∞–Ω–∏–µ swap –æ–ø–µ—Ä–∞—Ü–∏–∏
        let swap_id = uuid::Uuid::new_v4();
        let swap_operation = self.swap_engine.create_swap_operation(
            swap_id,
            user_id,
            from_chain,
            to_chain,
            amount,
            recipient,
        ).await?;

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
        self.save_swap_operation(&swap_operation).await?;

        Ok(SwapInitResponse {
            swap_id,
            status: SwapStatus::Initialized,
            estimated_time: chrono::Duration::minutes(5),
        })
    }
}
```

### –≠—Ç–∞–ø 3: Atomic Swap Engine

```rust
// src/swap_engine.rs - –∞—Ç–æ–º–∞—Ä–Ω–∞—è swap –ª–æ–≥–∏–∫–∞
use crate::{BridgeError, SwapOperation, SwapStatus};
use kembridge_crypto::QuantumKeyManager;

pub struct SwapEngine {
    quantum_manager: QuantumKeyManager,
}

impl SwapEngine {
    pub async fn new(quantum_manager: QuantumKeyManager) -> Result<Self, BridgeError> {
        Ok(Self { quantum_manager })
    }

    pub async fn execute_eth_to_near_swap(
        &self,
        swap_operation: &SwapOperation,
        ethereum_adapter: &EthereumAdapter,
        near_adapter: &NearAdapter,
    ) -> Result<SwapResult, BridgeError> {
        // Step 1: Quantum protection –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        let quantum_key_id = self.quantum_manager
            .generate_keys("bridge-operation", "ml-kem-1024")
            .await?;

        let protected_data = self.quantum_manager
            .protect_transaction_data(
                &swap_operation.serialize()?,
                &quantum_key_id,
            )?;

        // Step 2: Lock ETH –Ω–∞ Ethereum
        let lock_result = ethereum_adapter
            .lock_tokens_for_bridge(
                &swap_operation.swap_id.to_string(),
                swap_operation.amount,
                &protected_data,
            )
            .await?;

        // Step 3: Derive NEAR address —á–µ—Ä–µ–∑ Chain Signatures
        let near_address = near_adapter
            .chain_signatures
            .derive_ethereum_address(&swap_operation.recipient)
            .await?;

        // Step 4: Mint wrapped tokens –Ω–∞ NEAR
        let mint_result = near_adapter
            .mint_wrapped_tokens(
                swap_operation.amount,
                &near_address,
                &protected_data,
            )
            .await?;

        // Step 5: Verify atomic completion
        self.verify_atomic_completion(&lock_result, &mint_result).await?;

        Ok(SwapResult {
            swap_id: swap_operation.swap_id,
            eth_tx_hash: lock_result.transaction_hash,
            near_tx_hash: mint_result.transaction_hash,
            status: SwapStatus::Completed,
            quantum_key_id,
        })
    }

    async fn verify_atomic_completion(
        &self,
        lock_result: &EthereumLockResult,
        mint_result: &NearMintResult,
    ) -> Result<(), BridgeError> {
        // –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —á—Ç–æ –æ–±–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω—ã
        if !lock_result.confirmed || !mint_result.confirmed {
            return Err(BridgeError::AtomicOperationFailed);
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ quantum integrity
        if lock_result.quantum_hash != mint_result.quantum_hash {
            return Err(BridgeError::QuantumIntegrityViolation);
        }

        Ok(())
    }
}
```

### –≠—Ç–∞–ø 4: State Machine –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π

```rust
// src/state_machine.rs - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏
use crate::{SwapOperation, SwapStatus, BridgeError};

pub struct StateMachine {
    // State transitions map
    transitions: HashMap<SwapStatus, Vec<SwapStatus>>,
}

impl StateMachine {
    pub fn new() -> Self {
        let mut transitions = HashMap::new();
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π
        transitions.insert(
            SwapStatus::Initialized,
            vec![SwapStatus::EthLocking, SwapStatus::Failed, SwapStatus::Cancelled]
        );
        
        transitions.insert(
            SwapStatus::EthLocking,
            vec![SwapStatus::EthLocked, SwapStatus::Failed, SwapStatus::Timeout]
        );
        
        transitions.insert(
            SwapStatus::EthLocked,
            vec![SwapStatus::NearMinting, SwapStatus::Failed, SwapStatus::Timeout]
        );
        
        transitions.insert(
            SwapStatus::NearMinting,
            vec![SwapStatus::NearMinted, SwapStatus::Failed, SwapStatus::Timeout]
        );
        
        transitions.insert(
            SwapStatus::NearMinted,
            vec![SwapStatus::Completed, SwapStatus::Failed]
        );

        Self { transitions }
    }

    pub fn can_transition(&self, from: SwapStatus, to: SwapStatus) -> bool {
        self.transitions
            .get(&from)
            .map(|allowed| allowed.contains(&to))
            .unwrap_or(false)
    }

    pub async fn transition_state(
        &self,
        swap_operation: &mut SwapOperation,
        new_status: SwapStatus,
    ) -> Result<(), BridgeError> {
        if !self.can_transition(swap_operation.status, new_status) {
            return Err(BridgeError::InvalidStateTransition {
                from: swap_operation.status,
                to: new_status,
            });
        }

        swap_operation.status = new_status;
        swap_operation.updated_at = chrono::Utc::now();

        Ok(())
    }
}
```

### –≠—Ç–∞–ø 5: Timeout Manager –∏ Rollback

```rust
// src/timeout_manager.rs - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–∞—É—Ç–∞–º–∏
use crate::{SwapOperation, SwapStatus, BridgeError};
use tokio::time::{sleep, Duration};

pub struct TimeoutManager {
    default_timeout: Duration,
}

impl TimeoutManager {
    pub fn new() -> Self {
        Self {
            default_timeout: Duration::from_secs(300), // 5 –º–∏–Ω—É—Ç
        }
    }

    pub async fn monitor_operation_timeout(
        &self,
        swap_id: uuid::Uuid,
        bridge_service: Arc<BridgeService>,
    ) -> Result<(), BridgeError> {
        sleep(self.default_timeout).await;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–æ—Å–ª–µ —Ç–∞–π–º–∞—É—Ç–∞
        let operation = bridge_service
            .get_swap_operation(swap_id)
            .await?;

        match operation.status {
            SwapStatus::Completed => {
                // –û–ø–µ—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
                Ok(())
            }
            SwapStatus::Failed | SwapStatus::Cancelled => {
                // –û–ø–µ—Ä–∞—Ü–∏—è —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞
                Ok(())
            }
            _ => {
                // –û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–≤–∏—Å–ª–∞ - –∏–Ω–∏—Ü–∏–∏—Ä—É–µ–º rollback
                self.initiate_rollback(swap_id, bridge_service).await
            }
        }
    }

    async fn initiate_rollback(
        &self,
        swap_id: uuid::Uuid,
        bridge_service: Arc<BridgeService>,
    ) -> Result<(), BridgeError> {
        tracing::warn!("Initiating rollback for swap {}", swap_id);

        let operation = bridge_service
            .get_swap_operation(swap_id)
            .await?;

        match operation.status {
            SwapStatus::EthLocked => {
                // Unlock ETH tokens
                bridge_service
                    .ethereum_adapter
                    .unlock_tokens(&operation.swap_id.to_string())
                    .await?;
            }
            SwapStatus::NearMinted => {
                // Burn NEAR tokens and unlock ETH
                bridge_service
                    .near_adapter
                    .burn_wrapped_tokens(
                        operation.amount,
                        &operation.recipient,
                    )
                    .await?;

                bridge_service
                    .ethereum_adapter
                    .unlock_tokens(&operation.swap_id.to_string())
                    .await?;
            }
            _ => {
                // –î–ª—è –¥—Ä—É–≥–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π rollback –Ω–µ –Ω—É–∂–µ–Ω
            }
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏
        bridge_service
            .update_swap_status(swap_id, SwapStatus::RolledBack)
            .await?;

        Ok(())
    }
}
```

### –≠—Ç–∞–ø 6: HTTP API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

```rust
// HTTP handlers –¥–ª—è integration —Å –æ—Å–Ω–æ–≤–Ω—ã–º backend
use axum::{Json, extract::Path, response::Json as JsonResponse};
use kembridge_auth::AuthUser;

#[derive(serde::Deserialize)]
pub struct InitSwapRequest {
    pub from_chain: String,
    pub to_chain: String,
    pub amount: String, // String –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ —Å –±–æ–ª—å—à–∏–º–∏ —á–∏—Å–ª–∞–º–∏
    pub recipient: String,
}

#[derive(serde::Serialize)]
pub struct InitSwapResponse {
    pub swap_id: uuid::Uuid,
    pub status: String,
    pub estimated_time_minutes: i64,
}

pub async fn init_swap_handler(
    auth_user: AuthUser,
    Json(request): Json<InitSwapRequest>,
    bridge_service: Arc<BridgeService>,
) -> Result<JsonResponse<InitSwapResponse>, BridgeError> {
    let amount = request.amount.parse::<u128>()
        .map_err(|_| BridgeError::InvalidAmount)?;

    let result = bridge_service
        .init_swap(
            auth_user.id,
            &request.from_chain,
            &request.to_chain,
            amount,
            &request.recipient,
        )
        .await?;

    Ok(JsonResponse(InitSwapResponse {
        swap_id: result.swap_id,
        status: result.status.to_string(),
        estimated_time_minutes: result.estimated_time.num_minutes(),
    }))
}

pub async fn get_swap_status_handler(
    auth_user: AuthUser,
    Path(swap_id): Path<uuid::Uuid>,
    bridge_service: Arc<BridgeService>,
) -> Result<JsonResponse<SwapStatusResponse>, BridgeError> {
    let operation = bridge_service
        .get_swap_operation(swap_id)
        .await?;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å —ç—Ç—É –æ–ø–µ—Ä–∞—Ü–∏—é
    if operation.user_id != auth_user.id {
        return Err(BridgeError::Unauthorized);
    }

    Ok(JsonResponse(SwapStatusResponse {
        swap_id: operation.swap_id,
        status: operation.status.to_string(),
        from_chain: operation.from_chain,
        to_chain: operation.to_chain,
        amount: operation.amount.to_string(),
        created_at: operation.created_at,
        updated_at: operation.updated_at,
        eth_tx_hash: operation.eth_tx_hash,
        near_tx_hash: operation.near_tx_hash,
    }))
}
```

## üß™ –ü–æ—ç—Ç–∞–ø–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –≠—Ç–∞–ø 1: Unit —Ç–µ—Å—Ç—ã –¥–ª—è BridgeService

```rust
// tests/bridge_service_test.rs
#[tokio::test]
async fn test_bridge_service_creation() {
    let bridge_service = create_test_bridge_service().await;
    assert!(bridge_service.is_ok());
}

#[tokio::test]
async fn test_init_swap_validation() {
    let bridge_service = create_test_bridge_service().await.unwrap();
    
    let result = bridge_service
        .init_swap(
            uuid::Uuid::new_v4(),
            "ethereum",
            "near",
            1000000000000000000, // 1 ETH
            "test.near",
        )
        .await;
    
    assert!(result.is_ok());
    assert_eq!(result.unwrap().status, SwapStatus::Initialized);
}
```

### –≠—Ç–∞–ø 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã atomic swap

```rust
// tests/atomic_swap_test.rs
#[tokio::test]
async fn test_eth_to_near_atomic_swap() {
    let bridge_service = create_test_bridge_service().await.unwrap();
    
    // –°–æ–∑–¥–∞–µ–º swap –æ–ø–µ—Ä–∞—Ü–∏—é
    let swap_response = bridge_service
        .init_swap(
            uuid::Uuid::new_v4(),
            "ethereum",
            "near",
            1000000000000000000,
            "test.near",
        )
        .await
        .unwrap();
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º swap
    let swap_result = bridge_service
        .execute_swap(swap_response.swap_id)
        .await
        .unwrap();
    
    assert_eq!(swap_result.status, SwapStatus::Completed);
    assert!(swap_result.eth_tx_hash.is_some());
    assert!(swap_result.near_tx_hash.is_some());
}
```

### –≠—Ç–∞–ø 3: –¢–µ—Å—Ç—ã timeout –∏ rollback

```rust
// tests/timeout_rollback_test.rs
#[tokio::test]
async fn test_timeout_rollback() {
    let bridge_service = create_test_bridge_service().await.unwrap();
    
    // –°–æ–∑–¥–∞–µ–º swap –æ–ø–µ—Ä–∞—Ü–∏—é
    let swap_response = bridge_service
        .init_swap(
            uuid::Uuid::new_v4(),
            "ethereum",
            "near",
            1000000000000000000,
            "test.near",
        )
        .await
        .unwrap();
    
    // –°–∏–º—É–ª–∏—Ä—É–µ–º –∑–∞–ª–∏–ø–∞–Ω–∏–µ –Ω–∞ —ç—Ç–∞–ø–µ EthLocking
    bridge_service
        .update_swap_status(swap_response.swap_id, SwapStatus::EthLocking)
        .await
        .unwrap();
    
    // –ñ–¥–µ–º —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è timeout
    tokio::time::sleep(Duration::from_secs(6)).await;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª –≤—ã–ø–æ–ª–Ω–µ–Ω rollback
    let operation = bridge_service
        .get_swap_operation(swap_response.swap_id)
        .await
        .unwrap();
    
    assert_eq!(operation.status, SwapStatus::RolledBack);
}
```

## üìä –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

### –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ñ–∞–∑

| –ó–∞–¥–∞—á–∞ | –§–∞–∑–∞ | –°—Ç–∞—Ç—É—Å –≤ 4.3 | –û–ø–∏—Å–∞–Ω–∏–µ |
|--------|------|-------------|----------|
| **3.2.7** –†–æ—Ç–∞—Ü–∏—è –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –∫–ª—é—á–µ–π | 3.2 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å BridgeService –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π —Ä–æ—Ç–∞—Ü–∏–∏ |
| **3.4.4** HybridCrypto –∫–ª—é—á–∏ —Ä–æ—Ç–∞—Ü–∏—è | 3.4 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –°–≤—è–∑–∞–Ω–æ —Å 3.2.7 |
| **3.4.5** HybridCrypto HTTP endpoints | 3.4 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ BridgeService |
| **4.1.4** ETH —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å quantum wallet | 4.1 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | Quantum-protected ETH –æ–ø–µ—Ä–∞—Ü–∏–∏ |
| **4.1.5** Mock ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç | 4.1 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –°–æ–∑–¥–∞–Ω–∏–µ bridge –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ |
| **4.1.9** Event listeners –¥–ª—è ETH | 4.1 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ bridge –æ–ø–µ—Ä–∞—Ü–∏–π |
| **4.2.7** NEAR bridge —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç | 4.2 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å bridge logic |
| **4.2.8** –ö—Ä–æ—Å—Å-—á–µ–π–Ω –≤—ã–∑–æ–≤—ã | 4.2 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ BridgeService |
| **4.2.11** –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ NEAR —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π | 4.2 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | Event handling –¥–ª—è NEAR |
| **2.1.5** NEAR ed25519 RPC –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è | 2.1 | ‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è | –ü–æ–ª–Ω–∞—è –∑–∞–º–µ–Ω–∞ –∑–∞–≥–ª—É—à–∫–∏ |

### –ù–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è –±—É–¥—É—â–∏—Ö —Ñ–∞–∑

| –§–∞–∑–∞ | –ó–∞–≤–∏—Å–∏—Ç –æ—Ç 4.3 | –û–ø–∏—Å–∞–Ω–∏–µ |
|------|---------------|----------|
| **Phase 5.2** | BridgeService | AI Risk Engine –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ bridge workflow |
| **Phase 6.2** | Atomic Swap | 1inch Fusion+ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –¥–ª—è optimal pricing |
| **Phase 7.4** | HTTP API | Frontend –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è bridge –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ |
| **Phase 8.1** | Full Bridge | End-to-end –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ |

## üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –º–æ–¥—É–ª—è–º–∏

### Quantum Cryptography Integration

```rust
// –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∫–≤–∞–Ω—Ç–æ–≤–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
impl BridgeService {
    async fn quantum_protect_bridge_operation(
        &self,
        swap_operation: &SwapOperation,
    ) -> Result<QuantumProtectedData, BridgeError> {
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ML-KEM –∫–ª—é—á–µ–π –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–∏
        let key_pair = self.quantum_manager
            .generate_ml_kem_keys()
            .await?;

        // Hybrid encryption –¥–∞–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–∏
        let protected_data = self.quantum_manager
            .hybrid_encrypt(
                &swap_operation.serialize()?,
                &key_pair.public_key,
            )?;

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ quantum_keys —Ç–∞–±–ª–∏—Ü–µ
        self.quantum_manager
            .store_quantum_keys(
                &swap_operation.swap_id.to_string(),
                &key_pair,
                "bridge-operation",
            )
            .await?;

        Ok(protected_data)
    }
}
```

### Database Integration

```rust
// –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å transactions —Ç–∞–±–ª–∏—Ü–µ–π
impl BridgeService {
    async fn save_swap_operation(
        &self,
        swap_operation: &SwapOperation,
    ) -> Result<(), BridgeError> {
        let transaction = kembridge_database::models::Transaction {
            id: swap_operation.swap_id,
            user_id: swap_operation.user_id,
            from_chain: swap_operation.from_chain.clone(),
            to_chain: swap_operation.to_chain.clone(),
            amount: swap_operation.amount,
            status: swap_operation.status.to_string(),
            quantum_key_id: swap_operation.quantum_key_id.clone(),
            created_at: swap_operation.created_at,
            updated_at: swap_operation.updated_at,
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è bridge
            eth_tx_hash: swap_operation.eth_tx_hash.clone(),
            near_tx_hash: swap_operation.near_tx_hash.clone(),
            recipient: swap_operation.recipient.clone(),
        };

        sqlx::query!(
            "INSERT INTO transactions (id, user_id, from_chain, to_chain, amount, status, quantum_key_id, created_at, updated_at, eth_tx_hash, near_tx_hash, recipient) 
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)",
            transaction.id,
            transaction.user_id,
            transaction.from_chain,
            transaction.to_chain,
            transaction.amount.to_string(),
            transaction.status,
            transaction.quantum_key_id,
            transaction.created_at,
            transaction.updated_at,
            transaction.eth_tx_hash,
            transaction.near_tx_hash,
            transaction.recipient,
        )
        .execute(&self.db_pool)
        .await?;

        Ok(())
    }
}
```

## üìà –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

### –ü–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ Phase 4.3

- ‚úÖ **–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π BridgeService** —Å atomic swap –ª–æ–≥–∏–∫–æ–π
- ‚úÖ **ETH ‚Üí NEAR –æ–ø–µ—Ä–∞—Ü–∏–∏** —Å quantum –∑–∞—â–∏—Ç–æ–π
- ‚úÖ **NEAR ed25519 –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è** —Å –ø–æ–ª–Ω–æ–π RPC –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π
- ‚úÖ **Timeout –∏ rollback** –º–µ—Ö–∞–Ω–∏–∑–º—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- ‚úÖ **HTTP API endpoints** –¥–ª—è frontend –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
- ‚úÖ **Database integration** –¥–ª—è –∞—É–¥–∏—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏–π
- ‚úÖ **–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á** –∏–∑ Phases 2-4

### –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ Phase 5.1

```mermaid
graph TB
    subgraph "Phase 4.3: Basic Bridge Logic - –ì–û–¢–û–í–û"
        A[BridgeService] --> B[Atomic Swap Engine]
        A --> C[State Machine]
        A --> D[Timeout Manager]
        E[Quantum Manager] --> A
        F[ETH Adapter] --> A
        G[NEAR Adapter] --> A
        H[Database] --> A
    end
    
    subgraph "Phase 5.1: AI Risk Engine"
        I[Risk Analysis] --> A
        J[ML Scoring] --> A
        K[Real-time Monitoring] --> A
    end
    
    style A fill:#90EE90
    style B fill:#90EE90
    style C fill:#90EE90
    style D fill:#90EE90
    style E fill:#90EE90
    style F fill:#90EE90
    style G fill:#90EE90
    style H fill:#90EE90
```

## üìñ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å—ã

- **Atomic Swaps:** https://en.bitcoin.it/wiki/Atomic_swap
- **Cross-Chain Bridges:** https://ethereum.org/en/developers/docs/bridges/
- **State Machine Patterns:** https://statecharts.dev/
- **Quantum Cryptography Integration:** https://csrc.nist.gov/projects/post-quantum-cryptography

### –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

- **Ethereum Testing:** https://ethereum.org/en/developers/docs/development-frameworks/
- **NEAR Testing:** https://docs.near.org/smart-contracts/testing/introduction
- **Rust Async Programming:** https://tokio.rs/tokio/tutorial
- **Database Migrations:** https://docs.rs/sqlx/latest/sqlx/migrate/index.html

---

**Phase 4.3 Status:** –ì–æ—Ç–æ–≤ –∫ –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤—Å–µ—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ñ–∞–∑. –ë–∞–∑–æ–≤—ã–π –º–æ—Å—Ç –æ–±–µ—Å–ø–µ—á–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ ETH ‚Üí NEAR –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å quantum protection –∏ –ø–æ–ª–Ω–æ–π auditability.